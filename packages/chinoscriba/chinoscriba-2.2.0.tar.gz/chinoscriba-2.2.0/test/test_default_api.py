# coding: utf-8

"""
    Scriba API

    Audit log management API

    OpenAPI spec version: 0.1

    Generated by: https://github.com/swagger-api/swagger-codegen.git
    Implemented by: Andrea Arighi <andrea@chino.io>
                    Daniele Zanotelli <daniele@chino.io>

"""

from __future__ import absolute_import

import datetime
import io
import os
import time
import unittest
import zipfile
from unittest.mock import patch

from chinoscriba import Configuration, ApiClient, AuditLog
from chinoscriba import BlocksApi, EventsApi, LogsApi, StatsApi
from chinoscriba.rest import ApiException
from dateutil.tz import tzutc
from django.utils import timezone

from nose.plugins.attrib import attr

from .utils import _mock_nullable_stats


# # SDK Configuration
host = os.environ.get('host', "http://localhost:8000")
# Basic auth
configuration = Configuration()
configuration.host = host
configuration.username = os.environ.get(
    'customer_id', "NO AUTH (set the env variable 'customer_id')")
configuration.password = os.environ.get(
    'customer_key', "NO AUTH (set the env variable 'customer_key')")

# JWT auth
configuration_jwt = Configuration()
configuration_jwt.host = host
configuration_jwt.api_key_prefix['Authorization'] = "Bearer"
configuration_jwt.api_key = {
    'Authorization':
        os.environ.get('chino_jwt',
                       "NO AUTH (set the env variable 'chino_jwt')")
}


class ScribaTestCase(unittest.TestCase):
    """Base unittest.TestCase for Scriba SDK
    """
    api_class = None
    conf = None

    def setUpClass(cls=None):
        print("Using Scriba at: %s" % host)

        u = configuration.username
        print(f"username: {u[3:]}{'*' * len(u[:3])}")

        p = configuration.password
        print(f"password: {p[3:]}{'*' * len(p[:3])}")

    def setUp(self):
        if self.api_class and self.conf:
            self.api = self.api_class(ApiClient(self.conf))


class TestLogsApiBasicAuth(ScribaTestCase):
    """Api unit test for 'logs'  with BASIC auth
    """
    api_class = LogsApi
    conf = configuration

    def test_create_a_log(self):
        """Test case for create_a_log (Basic auth)
        """
        if "//localhost" not in configuration.host and \
                "//127.0.0.1" not in configuration.host:
            print("TEST SKIPPED")
            print("You are not running tests against localhost,")
            print("so this test will not be executed to prevent")
            print("creating useless logs.")
            return

        log = AuditLog()
        log.action = "SDK_TEST"
        log.message = "Test Python SDK: Create Log"

        # sync call
        res1 = self.api.logs_create(log)
        self.assertEqual(log.message, res1.message, "Wrong message.")
        self.assertEqual(log.action, res1.action, "Wrong action.")

        # async call
        thread = self.api.logs_create(async_req=True, body=log)
        res2 = thread.get()
        self.assertEqual(log.message, res2.message, "Wrong message")
        self.assertEqual(log.action, res2.action, "Wrong action")

    def test_create_bulk_logs(self):
        """Test case for create multiple logs (Basic auth)
        """
        if "//localhost" not in configuration.host and \
                "//127.0.0.1" not in configuration.host:
            print("TEST SKIPPED")
            print("You are not running tests against localhost,")
            print("so this test will not be executed to prevent")
            print("creating useless logs.")
            return

        log1 = AuditLog()
        log1.action = "SDK_TEST"
        log1.message = "Test Python SDK: Create Bulk (1)"
        log2 = AuditLog()
        log2.action = "SDK_TEST"
        log2.message = "Test Python SDK: Create Bulk (2)"

        # sync call
        res_sync = self.api.logs_multiple([log1, log2])
        self.assertEquals(0, len(res_sync.errors), f"Errors in response:\n"
                                                   f"{res_sync.errors}")
        # Check that the logs have been created
        results = self.api.logs_list(limit=10, offset=0).results
        self.assertGreater(len(results), 0, "Logs not created")

        # async call
        thread = self.api.logs_multiple(async_req=True, body=[log1, log2])
        res_async = thread.get()
        self.assertEquals(0, len(res_async.errors), f"Errors in response:\n"
                                                    f"{res_async.errors}")
        # Check that the logs have been created
        results = self.api.logs_list(limit=10, offset=0).results
        self.assertGreater(len(results), 0, "Logs not created")

    def test_list_logs(self):
        """Test case for list_logs (Basic auth)
        """
        limit = 10

        # sync
        res1 = self.api.logs_list(limit=limit, offset=0)
        self.assertTrue(len(res1.results) <= limit, "Too many results!")

        # async
        thread = self.api.logs_list(async_req=True, limit=limit, offset=0)
        res2 = thread.get()
        self.assertTrue(len(res2.results) <= limit, "Too many results!")

        # test `all` query param
        for bad_all_value in ('', 'antani'):
            with self.assertRaises(ApiException) as cm:
                self.api.logs_list(all=bad_all_value)

            self.assertEqual(400, cm.exception.status)

        # param value is case insensitive
        for good_all_value in ('true', 'false', 'TRue', 'faLSE'):
            self.api.logs_list(all=good_all_value)

    def test_search_logs(self):
        """Test case for search_logs (Basic auth)
        """
        body = {
            "query": {
                "or": [{
                    "field": "log_time",
                    "type": "gt",
                    "value": "2019-09-01"
                }]
            },
            "sort": [{
                "field": "begin_time",
                "order": "asc"
            }]
        }

        # sync
        res1 = self.api.logs_search(body=body)
        self.assertIsNotNone(res1.results, "Search returned no results!")

        # async
        thread = self.api.logs_search(async_req=True, body=body)
        res2 = thread.get()
        self.assertIsNotNone(res2.results, "Search returned no results!")


@attr('jwt')
class TestLogsApiJwt(TestLogsApiBasicAuth):
    """Same tests as TestLogsApiBasicAuth, but with JWT authentication.

    The docstring of the methods below is necessary to distinguish them from
    the tests in the superclass
    """
    conf = configuration_jwt


class TestExporterApiBasicAuth(ScribaTestCase):
    """Api unit test for 'exported' with BASIC auth
    """
    api_class = BlocksApi
    conf = configuration

    def test_exported_list(self):
        """Test case for the list of blocks to export (Basic auth)
        """
        limit = 10

        # sync
        res1 = self.api.exported_list(limit=limit, offset=0)
        self.assertTrue(len(res1.results) <= limit, "Too many results!")

        # async
        thread = self.api.exported_list(async_req=True, limit=limit, offset=0)
        res2 = thread.get()
        self.assertTrue(len(res2.results) <= limit, "Too many results!")

    def test_exported_read(self):
        """Test case for the export of log blocks (Basic auth)
        """
        # Check if there is at least 1 block
        blocks = self.api.exported_list(limit=1, offset=0)
        if blocks.count == 0:
            msg = "There are 0 blocks to export. Run \n"
            msg += "  python manage.py exportauditlogs "
            msg += "--settings settings.local --when <today>\n"
            msg += "to generate some."
            self.fail(msg)

        # If there is at least 1 block, test the download function.
        block = blocks.results[0]

        # sync
        res_sync = self.api.exported_read(block.block_id,
                                          _preload_content=False)
        self.assertIsNotNone(res_sync, "No response (sync)")
        # check if the .zip file has errors
        archive = zipfile.ZipFile(io.BytesIO(res_sync.data))
        self.assertIsNone(archive.testzip())

        # async
        thread = self.api.exported_read(block.block_id, async_req=True,
                                        _preload_content=False)
        res_async = thread.get()
        self.assertIsNotNone(res_async, "No response (async)")
        # check if the .zip file has errors
        archive = zipfile.ZipFile(io.BytesIO(res_async.data))
        self.assertIsNone(archive.testzip())


@attr('jwt')
class TestExporterApiJwt(TestExporterApiBasicAuth):
    """Same tests as TestExporterApiBasicAuth, but with JWT authentication.

    The docstring of the methods below is necessary to distinguish from the
    superclass methods.
    """
    conf = configuration_jwt


class TestEventsApiBasicAuth(ScribaTestCase):
    """Api unit test for events with BASIC auth
    """
    api_class = EventsApi
    conf = configuration

    def setUp(self):
        super(TestEventsApiBasicAuth, self).setUp()

        self.event_ids = []
        self.event_data = {
            'name': 'unittest_SDK_{}',
            'crontab': '* * * * *',
            'query': {'field': 'action', 'type': 'eq', 'value': 'sdk'},
            'action': {'type': 'fake_action'},
            'active': False
        }

    def tearDown(self):
        # try to remove the events created during the test
        for event_id in self.event_ids:
            try:
                self.api.events_delete(event_id)
            except Exception:
                pass

        super(TestEventsApiBasicAuth, self).tearDown()

    def test_create_an_event(self):
        """Test case for events_create (Basic Auth)
        """
        # sync call
        self.event_data['name'] = 'unittest_SDK_{}'.format(time.time())
        res1 = self.api.events_create(self.event_data)
        self.assertIsNotNone(res1.event_id)
        self.event_ids.append(res1.event_id)

        # async call
        self.event_data['name'] = 'unittest_SDK_{}'.format(time.time())
        thread = self.api.events_create(async_req=True, body=self.event_data)
        res2 = thread.get()
        self.assertIsNotNone(res1.event_id)
        self.event_ids.append(res2.event_id)

    def test_list_events(self):
        """Test case for events_list (Basic Auth)
        """
        # create the event
        self.event_data['name'] = 'unittest_SDK_{}'.format(time.time())
        res1 = self.api.events_create(self.event_data)
        self.assertIsNotNone(res1.event_id)
        self.event_ids.append(res1.event_id)

        # list: sync
        res2 = self.api.events_list()
        self.assertTrue(len(res2.results) > 0)
        self.assertEquals(res1.event_id, res2.results[0].event_id)

        # list: async
        thread = self.api.events_list(async_req=True)
        res3 = thread.get()
        self.assertTrue(len(res3.results) > 0)
        self.assertEquals(res1.event_id, res3.results[0].event_id)

    def test_read_event(self):
        """Test case for events_read (Basic Auth)
        """
        # create the event
        self.event_data['name'] = 'unittest_SDK_{}'.format(time.time())
        res1 = self.api.events_create(self.event_data)
        self.assertIsNotNone(res1.event_id)
        self.event_ids.append(res1.event_id)

        # read: sync
        res2 = self.api.events_read(res1.event_id)
        self.assertEquals(res1.event_id, res2.event_id)

        # read async
        thread = self.api.events_read(event_id=res1.event_id, async_req=True)
        res3 = thread.get()
        self.assertEquals(res1.event_id, res3.event_id)

    def test_update_event(self):
        """Test case for events_update (Basic Auth)
        """
        # create the event
        self.event_data['name'] = 'unittest_SDK_{}'.format(time.time())
        res1 = self.api.events_create(self.event_data)
        self.assertIsNotNone(res1.event_id)
        self.event_ids.append(res1.event_id)

        # update: sync
        self.event_data['name'] += "_updated"
        res2 = self.api.events_update(event_id=res1.event_id,
                                      body=self.event_data)
        self.assertEquals(self.event_data['name'], res2.name)

        # retrieve the object and check that name has changed
        res3 = self.api.events_read(event_id=res1.event_id)
        self.assertEquals(self.event_data['name'], res3.name)

        # update: async
        self.event_data['name'] += "_again"
        thread = self.api.events_update(event_id=res1.event_id, async_req=True,
                                        body=self.event_data)
        res4 = thread.get()
        self.assertEquals(self.event_data['name'], res4.name)

        # retrieve the object and check that name has changed
        res5 = self.api.events_read(event_id=res1.event_id)
        self.assertEquals(self.event_data['name'], res5.name)

    def test_partial_update_event(self):
        """Test case for events_partial_update (Basic Auth)
        """
        # create the event
        self.event_data['name'] = 'unittest_SDK_{}'.format(time.time())
        res1 = self.api.events_create(self.event_data)
        self.assertIsNotNone(res1.event_id)
        self.event_ids.append(res1.event_id)

        # partial update: sync
        data = {'name': self.event_data['name'] + "_updated"}
        res2 = self.api.events_partial_update(event_id=res1.event_id,
                                              body=data)
        self.assertEquals(data['name'], res2.name)

        # retrieve the object and check that name has changed
        res3 = self.api.events_read(event_id=res1.event_id)
        self.assertEquals(data['name'], res3.name)

        # update: async
        data['name'] += "_again"
        thread = self.api.events_partial_update(event_id=res1.event_id,
                                                async_req=True, body=data)
        res4 = thread.get()
        self.assertEquals(data['name'], res4.name)

        # retrieve the object and check that name has changed
        res5 = self.api.events_read(event_id=res1.event_id)
        self.assertEquals(data['name'], res5.name)

    def test_delete_event(self):
        """Test case for event_delete (Basic Auth)
        """
        # create the event
        self.event_data['name'] = 'unittest_SDK_{}'.format(time.time())
        res1 = self.api.events_create(self.event_data)
        self.assertIsNotNone(res1.event_id)
        self.event_ids.append(res1.event_id)

        # get the event
        res2 = self.api.events_read(event_id=res1.event_id)
        self.assertEquals(res1.event_id, res2.event_id)

        # delete: sync
        res3 = self.api.events_delete(event_id=res1.event_id)

        # get the event: check 404
        with self.assertRaises(ApiException) as cm:
            res4 = self.api.events_read(event_id=res1.event_id)

        self.assertEquals(404, cm.exception.status)

        # re-create the event
        self.event_data['name'] = 'unittest_SDK_{}'.format(time.time())
        res5 = self.api.events_create(self.event_data)
        self.assertIsNotNone(res5.event_id)
        self.event_ids.append(res5.event_id)

        # get the event
        res6 = self.api.events_read(event_id=res5.event_id)
        self.assertEquals(res5.event_id, res6.event_id)

        # delete: async
        thread = self.api.events_delete(event_id=res5.event_id, async_req=True)
        res7 = thread.get()

        # get the event: check 404
        with self.assertRaises(ApiException) as cm:
            res8 = self.api.events_read(event_id=res5.event_id)

        self.assertEquals(404, cm.exception.status)


@attr('jwt')
class TestEventsApiJwt(TestEventsApiBasicAuth):
    """Same tests as TestEventsApiBasicAuth, but with JWT authentication.
    """
    conf = configuration_jwt


class TestStatsApiBasicAuth(ScribaTestCase):
    """Api unit test for stats with BASIC auth
    """
    api_class = StatsApi
    conf = configuration

    def test_read_stats_no_ui(self):
        stats = self.api.stats_read()
        self._verify_stats(stats)

        # Make sure that the call actually doesn't return UI data
        for entry in stats.month_data:
            self.assertNotIn("CONSOLE_AUDIT", entry.keys())

    def test_read_stats_ui(self):
        self._verify_stats(
            self.api.stats_read(ui=True)
        )

    def test_read_stats_days_parameter(self):
        # Just check that it doesn't raise an exception with valid input
        self.api.stats_read(t=30)
        self.api.stats_read(t=60)
        self.api.stats_read(t=90)

        # Exception with invalid input
        with self.assertRaises(ApiException):
            self.api.stats_read(t=10)
        with self.assertRaises(ApiException):
                self.api.stats_read(t=None)
        with self.assertRaises(ApiException):
            self.api.stats_read(t="")

    @patch('chinoscriba.ApiClient.request', new_callable=_mock_nullable_stats)
    def test_nullable_items(self, mock_function):
        response = self.api.stats_read()
        print(response)
        # assert mock_function.called

        # fixme: restore when the SDK generator supports nullable fields
        # for nullable_field in ['manual_logs', 'all_logs', 'oldest_log',
        #                        'oldest_block']:
        #     value = getattr(response, nullable_field, "NOT SET")
        #     self.assertIsNone(value, msg=f"'{nullable_field}' should be None")

        # ...and remove the code below
        self.assertEquals(0, response.manual_logs)
        self.assertEquals(0, response.all_logs)
        # using 2001 because that's how it gets deserialized by the SDK
        self.assertEquals(datetime.datetime(2001, 1, 1, 0, 0, tzinfo=tzutc()),
                          response.oldest_log)
        self.assertEquals(datetime.datetime(2001, 1, 1, 0, 0, tzinfo=tzutc()),
                          response.oldest_block)

    def _verify_stats(self, stats):
        """The stats object in its dict() format
        """
        # check structure of serialized object
        stats_keys = {
            "manual_logs", "all_logs", "oldest_log", "total_blocks",
            "total_log_in_blocks", "oldest_block", "month_data",
        }

        # Check that all the expected stats are present in the response
        for item in stats_keys:
            self.assertNotEquals("MISSING", getattr(stats, item, "MISSING"),
                                 msg=f"Missing required key {item} "
                                     f"in Stats object")


@attr('jwt')
class TestStatsApiJwt(TestStatsApiBasicAuth):
    """Same tests as TestStatsApiBasicAuth, but with JWT authentication.
    """
    conf = configuration_jwt


if __name__ == '__main__':
    unittest.main()
