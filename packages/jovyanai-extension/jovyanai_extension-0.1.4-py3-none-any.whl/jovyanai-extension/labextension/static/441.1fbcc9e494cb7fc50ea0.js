"use strict";(self.webpackChunk_jovyanai_labextension=self.webpackChunk_jovyanai_labextension||[]).push([[441],{441:(e,s,t)=>{t.r(s),t.d(s,{JovyanClient:()=>i});var n=null;"undefined"!=typeof WebSocket?n=WebSocket:"undefined"!=typeof MozWebSocket?n=MozWebSocket:void 0!==t.g?n=t.g.WebSocket||t.g.MozWebSocket:"undefined"!=typeof window?n=window.WebSocket||window.MozWebSocket:"undefined"!=typeof self&&(n=self.WebSocket||self.MozWebSocket);var o=n,r=class{debug(e,...s){console.debug(`[DEBUG] ${e}`,...s)}info(e,...s){console.info(`[INFO] ${e}`,...s)}warn(e,...s){console.warn(`[WARN] ${e}`,...s)}error(e,...s){console.error(`[ERROR] ${e}`,...s)}},a=class{toolExecutions;executors;constructor(e=new Map){this.toolExecutions=new Map,this.executors=e}handleError(e,s,t){console.error(s),t({type:"agent:tool_use_result",payload:{toolCall:{result:s,toolCallId:e}}})}handleMessage(e,s){const t=e.payload.toolCall.toolCallId;if(this.toolExecutions.has(t)){const n=this.toolExecutions.get(t);if(!n)return void this.handleError(t,`Tool call ID ${t} not found in toolExecutions map.`,s);n.handleMessage(e,s)}else{if("agent:tool_use_complete"==e.type){const e=`Tool call ID ${t} not found in toolExecutions map but received complete message.`;return void this.handleError(t,e,s)}const n=e.payload.toolCall.toolName,o=this.executors.get(n);o?(this.toolExecutions.set(t,o),o.handleMessage(e,s)):this.handleError(t,`Tool executor for tool name ${n} not found.`,s)}}registerToolExecutor(e,s){this.executors.set(e,s)}},i=(new a,class{constructor(e,s,t,n){this.url=e,this.jwtToken=s,this.userId=t,this.logger=n||new r,this.currentToken=s}ws=null;sessionId=null;messageHandlers=new Map;messageQueue=[];isConnected=!1;isAuthenticated=!1;currentToken=null;logger;async connect(){return new Promise(((e,s)=>{try{this.ws=new o(this.url),this.ws.onopen=async()=>{this.logger.info("Connected to Jovyan AI server"),this.isConnected=!0;try{await this.authenticate(),this.processMessageQueue(),e()}catch(e){this.logger.error("Authentication failed:",e),s(e)}},this.ws.onerror=e=>{this.logger.error("WebSocket error:",e),this.isConnected=!1,s(new Error("Connection failed"))},this.ws.onclose=()=>{this.isConnected=!1,this.isAuthenticated=!1},this.ws.onmessage=e=>{try{const s=JSON.parse(e.data.toString()),t=this.messageHandlers.get(s.type);t&&t(s)}catch(e){this.logger.error("Error handling message:",e)}}}catch(e){s(e)}}))}async authenticate(){return new Promise(((e,s)=>{if(!this.isConnected||!this.ws)return void s(new Error("Not connected to server"));this.messageHandlers.set("auth:success",(s=>{if("auth:success"===s.type){const t=s;this.isAuthenticated=!0,this.currentToken=t.payload.token,e()}})),this.messageHandlers.set("error",(e=>{"error"===e.type&&s(new Error(e.payload.message))}));const t={type:"auth",payload:{token:this.currentToken}};this.ws.send(JSON.stringify(t))}))}processMessageQueue(){for(;this.messageQueue.length>0&&this.isConnected&&this.isAuthenticated;){const e=this.messageQueue.shift();e&&this.send(e)}}send(e){this.isConnected&&this.isAuthenticated?this.ws&&this.ws.send(JSON.stringify(e)):this.messageQueue.push(e)}async startSession(){return new Promise(((e,s)=>{if(!this.isConnected||!this.isAuthenticated)return void s(new Error("Not connected or not authenticated"));const t={type:"session:start",payload:{userId:this.userId}};this.messageHandlers.set("session:started",(t=>{"session:started"===t.type&&(this.sessionId=t.payload.sessionId,this.sessionId?e(this.sessionId):s(new Error("Session ID is null")))})),this.send(t)}))}async generateCode(e){return console.warn("Warning: generateCode() is deprecated. Please use generateCodeStream() instead."),new Promise(((s,t)=>{if(!this.isConnected)return void t(new Error("Not connected to server"));const n={type:"cell:generate_code",payload:e};this.messageHandlers.set("cell:generated_code",(e=>{"cell:generated_code"===e.type&&s(e.payload.generatedCode)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&t(new Error(e.payload.message))})),this.send(n)}))}async generateCodeStream(e,s){return this.isConnected?new Promise(((t,n)=>{const o={type:"cell:generate_code",payload:{...e,stream:!0}};let r="";this.messageHandlers.set("cell:generated_code_chunk",(e=>{if("cell:generated_code_chunk"===e.type){const t=e.payload.content;r+=t,s(t)}})),this.messageHandlers.set("cell:generated_code_complete",(e=>{"cell:generated_code_complete"===e.type&&t()})),this.messageHandlers.set("error",(e=>{"error"===e.type&&n(new Error(e.payload.message))})),this.send(o)})):Promise.reject(new Error("Not connected to server"))}async suggestNextAction(e){return new Promise(((s,t)=>{if(!this.isConnected)return void t(new Error("Not connected to server"));const n={type:"cell:next_action_suggestion",payload:e};this.messageHandlers.set("cell:next_action_response",(e=>{"cell:next_action_response"===e.type&&s(e.payload.nextAction)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&t(new Error(e.payload.message))})),this.send(n)}))}async sendUserMessage(e,s){return console.warn("Warning: sendUserMessage() is deprecated. Please use sendUserMessageStream() instead."),new Promise(((t,n)=>{if(!this.isConnected)return void n(new Error("Not connected to server"));const o={type:"agent:user_message",payload:{message:e,context:s}};this.messageHandlers.set("agent:agent_message",(e=>{"agent:agent_message"===e.type&&t(e.payload.message)})),this.messageHandlers.set("error",(e=>{"error"===e.type&&n(new Error(e.payload.message))})),this.send(o)}))}async sendUserMessageStream(e,s,t){return this.isConnected?new Promise(((n,o)=>{const r={type:"agent:user_message",payload:{message:e,context:s,stream:!0}};let i="";s.tools||(s.tools=[]);const c=new a;s.tools.forEach((e=>{c.registerToolExecutor(e.name,e)})),this.messageHandlers.set("agent:agent_message_chunk",(e=>{if("agent:agent_message_chunk"===e.type){const s=e.payload.content;i+=s,t(s)}})),this.messageHandlers.set("agent:agent_message_complete",(e=>{"agent:agent_message_complete"===e.type&&n()})),this.messageHandlers.set("error",(e=>{"error"===e.type&&o(new Error(e.payload.message))})),this.messageHandlers.set("agent:tool_use_chunk",(e=>{"agent:tool_use_chunk"===e.type&&c.handleMessage(e,this.send.bind(this))})),this.messageHandlers.set("agent:tool_use_complete",(e=>{"agent:tool_use_complete"===e.type&&c.handleMessage(e,this.send.bind(this))})),this.send(r)})):Promise.reject(new Error("Not connected to server"))}async close(){if(this.ws)return new Promise((e=>{this.ws.onclose=()=>{this.ws=null,this.isConnected=!1,this.isAuthenticated=!1,this.messageHandlers.clear(),this.messageQueue=[],e()},this.ws.close()}))}_setConnected(e){this.isConnected=e}})}}]);