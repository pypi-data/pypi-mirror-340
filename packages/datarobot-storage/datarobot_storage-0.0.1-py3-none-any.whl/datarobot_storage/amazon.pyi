import botocore.client
import collections
import types
from _typeshed import Incomplete
from builtins import object
from datarobot_storage.base import SeekableKeyInterface as SeekableKeyInterface, SeekableStorage as SeekableStorage, Storage as Storage, StorageGenerator as StorageGenerator
from datarobot_storage.enums import S3ServerSideEncryption as S3ServerSideEncryption
from datarobot_storage.put_generator import PutGenerator as PutGenerator
from datarobot_storage.utils import ClientPool as ClientPool, StorageUtilsMixin as StorageUtilsMixin, cached_property as cached_property, retry as retry
from typing import Any, Callable, Dict, Iterable, List, Optional, Type, Union
from typing_extensions import Self

logger: Incomplete
NA: Incomplete

class S3InternalError(Exception): ...

class MPUploaderBase:
    def upload_part(self, file_object, part_number) -> None: ...
    def abort_multipart_upload(self) -> None: ...
    def complete_upload(self) -> None: ...
    def complete_upload_with_retry(self): ...

class S3Key(SeekableKeyInterface):
    def __init__(self, key) -> None: ...
    @property
    def boto_key(self): ...
    @property
    def name(self): ...
    @property
    def size(self): ...
    @property
    def last_modified(self): ...
    def delete(self): ...
    def get_generator_factory(self, chunk_size=...) -> Callable: ...
    def get_range(self, offset: int, size: int) -> bytes: ...

class Boto3MultiPartUploader(MPUploaderBase):
    parts: Incomplete
    client: Incomplete
    mp: Incomplete
    def __init__(self, bucket, s3_config, key_name) -> None: ...
    def complete_upload(self) -> None: ...
    def upload_part(self, file_object, part_number) -> None: ...
    def abort_multipart_upload(self) -> None: ...

class S3Configuration:
    aws_access_key_id: Optional[str]
    aws_secret_access_key: Optional[str]
    aws_session_token: Optional[str]
    aws_profile: Optional[str]
    aws_ca_bundle: Optional[str]
    s3_host: str
    s3_port: int
    s3_bucket: str
    s3_region: str
    s3_service: str
    s3_is_secure: bool
    s3_validate_certs: bool
    s3_addressing_style: str
    sse: str
    sse_kms_key_id: str
    boto_http_socket_timeout: int
    boto_num_retries: int
    boto_metadata_service_timeout: int
    boto_metadata_service_num_attempts: int
    botocore_extra_ciphers: str
    local_data_directory: str
    prefix: str
    multipart_upload_enabled: bool
    multipart_download_enabled: bool
    def __init__(self, aws_access_key_id: Optional[str] = None, aws_secret_access_key: Optional[str] = None, aws_session_token: Optional[str] = None, aws_profile: Optional[str] = None, aws_ca_bundle: Optional[str] = None, s3_host: str = '', s3_port: int = 443, s3_bucket: str = '', s3_region: str = '', s3_service: str = '', s3_is_secure: bool = True, s3_validate_certs: bool = True, s3_addressing_style: str = 'auto', s3_server_side_encryption: str = ..., s3_server_side_encryption_key_id: str = '', boto_http_socket_timeout: int = 150, boto_num_retries: int = 7, boto_metadata_service_timeout: int = 2, boto_metadata_service_num_attempts: int = 7, botocore_extra_ciphers: str = '', local_data_directory: str = '', prefix: str = '', multipart_upload_enabled: bool = True, multipart_download_enabled: bool = True) -> None: ...
    @staticmethod
    def get_int(mapping, key) -> Union[int, object]: ...
    @staticmethod
    def get_bool(mapping, key) -> Union[bool, object]: ...
    @classmethod
    def from_dict(cls, _dict: collections.abc.Mapping) -> Self: ...
    @classmethod
    def from_environ(cls) -> Self: ...
    @property
    def s3_encryption_type(self) -> str: ...
    @property
    def encrypt_key(self) -> bool: ...
    @property
    def server_side_encryption_kwargs(self) -> Dict[str, str]: ...
    @property
    def endpoint_url(self) -> str: ...

class BaseBotoDriver:
    MultipartUploader: Optional[type]
    CHUNK_SIZE: Incomplete
    pagination_config: Dict[str, Any]
    s3_config: Incomplete
    def __init__(self, s3_config) -> None: ...
    def patch_libraries(self) -> None: ...
    def bucket_multipart_upload(self, bucket, key_name, filename, chunk_size, callback, logging_info) -> None: ...

class Boto3Driver(BaseBotoDriver):
    MultipartUploader = Boto3MultiPartUploader
    def boto_module(self): ...
    def create_session(self): ...
    @property
    def boto_config(self): ...
    def create_connection(self): ...
    @staticmethod
    def get_bucket(connection, bucket_name): ...
    def bucket_get_key(self, bucket, key_name, load_key: bool = True) -> Optional[S3Key]: ...
    def bucket_key_exists(self, bucket, key_name) -> bool: ...
    def bucket_list(self, bucket, prefix: Incomplete | None = None, delimiter: Incomplete | None = None, recursive: bool = False): ...
    def bucket_download(self, bucket, key_name, filename, transfer_config: Incomplete | None = None, callback: Incomplete | None = None) -> None: ...
    def bucket_multipart_download(self, bucket, key_name, filename, chunk_size, callback): ...
    def bucket_generator_download(self, key): ...
    def bucket_upload(self, bucket, key_name, filename) -> None: ...
    def bucket_delete_key(self, bucket, key_name): ...
    @staticmethod
    def bucket_delete_key_batch(bucket, key_name_list) -> None: ...
    def bucket_copy_key(self, bucket, dest_key_name, source_key_name) -> None: ...
    def bucket_generate_presigned_url(self, bucket, key_name, lifetime) -> Optional[str]: ...

class bucket_from_pool:
    bucket_pool: Incomplete
    MAX_RETRY_ATTEMPTS: int
    storage: Incomplete
    bucket: Incomplete
    use_bucket_pool: Incomplete
    def __init__(self, storage) -> None: ...
    def __enter__(self): ...
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: types.TracebackType) -> None: ...

class S3Storage(Storage, StorageUtilsMixin):
    MULTIPART_CHUNK_SIZE: int
    config: S3Configuration
    prefix: str
    local_data_directory: str
    driver: Boto3Driver
    get_cb: Callable
    put_cb: Callable
    use_bucket_pool: bool
    def __init__(self, bucket: Optional[str] = None, use_bucket_pool: bool = False, get_cb: Optional[Callable] = None, put_cb: Optional[Callable] = None, storage_config: Optional[S3Configuration] = None) -> None: ...
    def get_key_name(self, name) -> str: ...
    @property
    def client(self) -> botocore.client.BaseClient: ...
    @property
    def bucket_name(self) -> str: ...
    def bucket(self): ...
    def get_bucket(self): ...
    def download_handler(self, transmitted: int, total: int) -> None: ...
    def upload_handler(self, offset: int, nbytes: int, total: int) -> None: ...
    def exists(self, name: str) -> bool: ...
    def list(self, path: str, recursive: bool = False) -> List[str]: ...
    def get_large(self, name: str, temp_filename: str) -> bool: ...
    def get_seekable(self, name: str) -> SeekableStorage: ...
    def get(self, name: str, temp_filename: str) -> bool: ...
    def get_generator(self, name: str, **kwargs) -> StorageGenerator: ...
    def put_large(self, name: str, source_path: str) -> bool: ...
    def put(self, name: str, local_filename: str) -> bool: ...
    def put_generator(self, name: str, source: PutGenerator) -> bool: ...
    def copy(self, name: str, new_name: str) -> bool: ...
    def delete(self, name: str) -> bool: ...
    def url(self, name: str, expires_in: Optional[int] = 600) -> Optional[str]: ...
    def file_size(self, name: str) -> int: ...
    def delete_batch(self, name_iter: Iterable, batch_size: Optional[int] = 1000) -> None: ...
    def delete_all(self, name: str) -> None: ...
    def last_modified_get_downloadable_package_info(self, name: str): ...
    def list_keys_by_prefix(self, prefix: str): ...
    def root_location(self) -> str: ...
