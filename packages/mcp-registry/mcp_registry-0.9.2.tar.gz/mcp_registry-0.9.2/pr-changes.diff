diff --git a/README-tool-filtering.md b/README-tool-filtering.md
new file mode 100644
index 0000000..e081676
--- /dev/null
+++ b/README-tool-filtering.md
@@ -0,0 +1,138 @@
+# MCP Registry Tool Filtering
+
+This document provides examples and best practices for using the new server and tool filtering capabilities in MCP Registry.
+
+## Server-level Filtering
+
+Server-level filtering allows you to work with a subset of the configured servers. This is more efficient than filtering during operations, as it prevents loading unnecessary server configurations.
+
+### Using ServerRegistry.filter_servers
+
+```python
+from mcp_registry.compound import ServerRegistry, MCPAggregator
+
+# Create or load a registry with all servers
+full_registry = ServerRegistry.from_config(config_path)
+
+# Create a filtered registry with only specified servers
+memory_github_registry = full_registry.filter_servers(["memory", "github"])
+
+# Create an aggregator with the filtered registry
+aggregator = MCPAggregator(memory_github_registry)
+
+# Use the aggregator normally - only has access to specified servers
+tools = await aggregator.list_tools()
+result = await aggregator.call_tool("memory__get", {"key": "test"})
+```
+
+### CLI Usage
+
+The `mcp-registry serve` command uses server filtering when you specify server names:
+
+```bash
+# Serve all servers
+mcp-registry serve
+
+# Serve only specific servers
+mcp-registry serve memory github
+```
+
+## Tool-level Filtering
+
+Tool-level filtering allows you to expose only specific tools from each server. This doesn't reduce connection overhead but simplifies the exposed API and can be useful for security and organization.
+
+### Basic Tool Filtering
+
+```python
+from mcp_registry.compound import ServerRegistry, MCPAggregator
+
+# Create or load a registry
+registry = ServerRegistry.from_config(config_path)
+
+# Define which tools to expose from each server
+tool_filter = {
+    "memory": ["get", "set"],  # Only include get/set from memory
+    "github": ["list_repos", "create_issue"],  # Only specific github tools
+    "everything": None,  # Include all tools from 'everything' server
+}
+
+# Create an aggregator with the tool filter
+aggregator = MCPAggregator(registry, tool_filter=tool_filter)
+
+# Only the specified tools will be visible and callable
+tools = await aggregator.list_tools()
+```
+
+### Tool Filter Configurations
+
+```python
+# Include all tools from all servers (default behavior)
+tool_filter = {}  # or None
+
+# Include no tools from a server (empty list)
+tool_filter = {
+    "unsafe_server": []  # No tools from this server will be exposed
+}
+
+# Include all tools from specific servers
+tool_filter = {
+    "memory": None,  # All tools from memory server
+    "github": None   # All tools from github server
+}
+
+# Mix of specific tools and all tools
+tool_filter = {
+    "memory": ["get", "set", "delete"],
+    "github": None,
+    "filesystem": ["read_file", "list_directory"]
+}
+```
+
+## Combining Both Filtering Levels
+
+For maximum control, you can combine both filtering levels:
+
+```python
+# Step 1: Filter at the server level (which servers to connect to)
+filtered_registry = full_registry.filter_servers(["memory", "github", "filesystem"])
+
+# Step 2: Filter at the tool level (which tools to expose)
+tool_filter = {
+    "memory": ["get", "set"],
+    "github": ["list_repos", "create_issue"],
+    "filesystem": ["read_file", "list_directory"]
+}
+
+# Create aggregator with both filtering levels
+aggregator = MCPAggregator(filtered_registry, tool_filter=tool_filter)
+```
+
+## Best Practices
+
+1. **Use server-level filtering for efficiency**: When you know which servers you need, use `filter_servers` to avoid loading unnecessary configurations.
+
+2. **Use tool-level filtering for API simplification**: Use tool filters when you want to expose a clean, simplified API or restrict access to certain tools.
+
+3. **Prefer registry filtering over MCPAggregator server_names**: The `server_names` parameter in MCPAggregator still works but is less efficient than `filter_servers`.
+
+4. **Document your filtering**: When building applications that filter tools, consider documenting which tools you're exposing to make it clear to users.
+
+## Usage with Persistent Connections
+
+Both filtering techniques work with persistent connections:
+
+```python
+# Create filtered registry and tool filter
+filtered_registry = full_registry.filter_servers(["memory", "github"])
+tool_filter = {
+    "memory": ["get", "set"],
+    "github": ["list_repos"]
+}
+
+# Use with persistent connections
+async with MCPAggregator(filtered_registry, tool_filter=tool_filter) as aggregator:
+    # All tool calls use persistent connections
+    # Only the filtered tools are available
+    result1 = await aggregator.call_tool("memory__get", {"key": "test"})
+    result2 = await aggregator.call_tool("memory__set", {"key": "test", "value": "hello"})
+```
\ No newline at end of file
diff --git a/src/mcp_registry/compound.py b/src/mcp_registry/compound.py
index ec7335d..436368d 100644
--- a/src/mcp_registry/compound.py
+++ b/src/mcp_registry/compound.py
@@ -347,7 +347,15 @@ class MCPAggregator:
         aggregator = MCPAggregator(registry)
         result = await aggregator.call_tool("memory__get", {"key": "test"})
 
-        # Method 2: Persistent connections with context manager
+        # Method 2: Filtered tools - only expose certain tools
+        tool_filter = {
+            "memory": ["get", "set"],  # Only include get/set from memory
+            "github": ["list_repos", "create_issue"],  # Only specific github tools
+        }
+        aggregator = MCPAggregator(registry, tool_filter=tool_filter)
+        result = await aggregator.call_tool("memory__get", {"key": "test"})
+
+        # Method 3: Persistent connections with context manager
         async with MCPAggregator(registry) as aggregator:
             # All tool calls in this block will use persistent connections
             result1 = await aggregator.call_tool("memory__get", {"key": "test"})
@@ -357,12 +365,19 @@ class MCPAggregator:
     Attributes:
         registry: The ServerRegistry containing server configurations
         server_names: List of server names to include in the aggregator
+        tool_filter: Dictionary mapping server names to lists of tool names to include
         separator: Character(s) used to separate server name from tool name
         _namespaced_tool_map: Internal mapping of namespaced tool names to tool information
         _connection_manager: Connection manager for persistent connections (when used as context manager)
         _in_context_manager: Flag indicating if the aggregator is being used as a context manager
     """
-    def __init__(self, registry: ServerRegistry, server_names: list[str] | None = None, separator: str = "__"):
+    def __init__(
+        self, 
+        registry: ServerRegistry, 
+        server_names: list[str] | None = None, 
+        tool_filter: dict[str, list[str] | None] | None = None,
+        separator: str = "__"
+    ):
         """
         Initialize the aggregator.
         
@@ -370,11 +385,16 @@ class MCPAggregator:
             registry: ServerRegistry containing server configurations
             server_names: Optional list of specific server names to include
                          (defaults to all servers in the registry)
+                         Note: Consider using registry.filter_servers() instead for better efficiency
+            tool_filter: Optional dict mapping server names to lists of tool names to include.
+                        If a server is mapped to None, all tools from that server are included.
+                        If a server is not in the dict, all tools from that server are included.
             separator: Separator string between server name and tool name
                       (defaults to "__")
         """
         self.registry = registry
         self.server_names = server_names or registry.list_servers()
+        self.tool_filter = tool_filter or {}
         self._namespaced_tool_map: dict[str, NamespacedTool] = {}
         self._connection_manager = None
         self._in_context_manager = False
@@ -495,10 +515,29 @@ class MCPAggregator:
         # Load tools from all servers concurrently
         results = await gather(*(load_server_tools(name) for name in servers_to_load))
         
-        # Process and namespace the tools
+        # Helper function to check if a tool should be included based on the filter settings
+        def should_include_tool(server_name: str, tool_name: str) -> bool:
+            """Determine if a tool should be included based on the filter settings."""
+            # If server not in tool_filter, include all tools
+            if server_name not in self.tool_filter:
+                return True
+                
+            # If filter for server is None, include all tools
+            if self.tool_filter[server_name] is None:
+                return True
+                
+            # Only include tools in the specified list
+            return tool_name in self.tool_filter[server_name]
+            
+        # Process and namespace the tools with filtering
         for server_name, tools in results:
             for tool in tools:
                 original_name = tool.name
+                
+                # Skip this tool if it should be filtered out
+                if not should_include_tool(server_name, original_name):
+                    continue
+                
                 namespaced_name = f"{server_name}{self.separator}{original_name}"
                 # Create a copy of the tool with the namespaced name
                 namespaced_tool = tool.model_copy(update={"name": namespaced_name})
diff --git a/tests/test_compound/test_tool_filter.py b/tests/test_compound/test_tool_filter.py
new file mode 100644
index 0000000..bec8802
--- /dev/null
+++ b/tests/test_compound/test_tool_filter.py
@@ -0,0 +1,196 @@
+"""Tests for the tool filtering functionality in MCPAggregator."""
+
+import pytest
+import asyncio
+from unittest.mock import AsyncMock, MagicMock, patch
+
+from mcp.types import ListToolsResult, Tool
+from mcp_registry.compound import ServerRegistry, MCPAggregator, MCPServerSettings
+
+
+@pytest.fixture
+def mock_registry():
+    """Create a mock registry with two servers."""
+    # Mock server settings
+    settings1 = MCPServerSettings(type="stdio", command="cmd1", args=["arg1"])
+    settings2 = MCPServerSettings(type="stdio", command="cmd2", args=["arg2"])
+    
+    # Create registry with mock settings
+    registry = ServerRegistry({
+        "server1": settings1,
+        "server2": settings2
+    })
+    
+    # Create a mock get_client method for the registry
+    async def mock_get_client(server_name):
+        # Create a mock client session
+        client = AsyncMock()
+        
+        # Configure mock tools for each server
+        if server_name == "server1":
+            tools = [
+                Tool(name="tool1", description="Tool 1", inputSchema={}),
+                Tool(name="tool2", description="Tool 2", inputSchema={}),
+                Tool(name="tool3", description="Tool 3", inputSchema={})
+            ]
+        else:  # server2
+            tools = [
+                Tool(name="toolA", description="Tool A", inputSchema={}),
+                Tool(name="toolB", description="Tool B", inputSchema={}),
+            ]
+        
+        # Configure the client's list_tools method
+        client.list_tools.return_value = ListToolsResult(tools=tools)
+        
+        # Create an async context manager to yield the client
+        class AsyncContextManager:
+            async def __aenter__(self):
+                return client
+            
+            async def __aexit__(self, exc_type, exc_val, exc_tb):
+                pass
+        
+        return AsyncContextManager()
+    
+    # Add the mock get_client method to the registry
+    registry.get_client = mock_get_client
+    
+    return registry
+
+
+@pytest.mark.asyncio
+async def test_tool_filter_init():
+    """Test that tool_filter is properly initialized."""
+    registry = MagicMock()
+    tool_filter = {"server1": ["tool1", "tool2"]}
+    
+    aggregator = MCPAggregator(registry, tool_filter=tool_filter)
+    
+    assert aggregator.tool_filter == tool_filter
+
+
+@pytest.mark.asyncio
+async def test_tool_filter_empty():
+    """Test that an empty tool_filter defaults to include all tools."""
+    registry = MagicMock()
+    
+    aggregator = MCPAggregator(registry, tool_filter={})
+    
+    assert aggregator.tool_filter == {}
+
+
+@pytest.mark.asyncio
+async def test_tool_filter_none():
+    """Test that a None tool_filter defaults to include all tools."""
+    registry = MagicMock()
+    
+    aggregator = MCPAggregator(registry, tool_filter=None)
+    
+    assert aggregator.tool_filter == {}
+
+
+@pytest.mark.asyncio
+async def test_load_servers_with_tool_filter(mock_registry):
+    """Test that tools are filtered when loading servers."""
+    # Create aggregator with tool filter - only include tool1 from server1 and all tools from server2
+    tool_filter = {
+        "server1": ["tool1"],  # Only include tool1 from server1
+        "server2": None,  # Include all tools from server2
+    }
+    aggregator = MCPAggregator(mock_registry, tool_filter=tool_filter)
+    
+    # Load the servers
+    await aggregator.load_servers()
+    
+    # Check which tools were loaded
+    namespaced_tools = list(aggregator._namespaced_tool_map.keys())
+    assert "server1__tool1" in namespaced_tools
+    assert "server1__tool2" not in namespaced_tools
+    assert "server1__tool3" not in namespaced_tools
+    assert "server2__toolA" in namespaced_tools
+    assert "server2__toolB" in namespaced_tools
+
+
+@pytest.mark.asyncio
+async def test_load_servers_with_empty_tool_list(mock_registry):
+    """Test that an empty tool list filters out all tools from that server."""
+    # Create aggregator with tool filter - empty list for server1 means include no tools
+    tool_filter = {
+        "server1": [],  # Include no tools from server1
+        "server2": ["toolA"],  # Only include toolA from server2
+    }
+    aggregator = MCPAggregator(mock_registry, tool_filter=tool_filter)
+    
+    # Load the servers
+    await aggregator.load_servers()
+    
+    # Check which tools were loaded
+    namespaced_tools = list(aggregator._namespaced_tool_map.keys())
+    assert "server1__tool1" not in namespaced_tools
+    assert "server1__tool2" not in namespaced_tools
+    assert "server1__tool3" not in namespaced_tools
+    assert "server2__toolA" in namespaced_tools
+    assert "server2__toolB" not in namespaced_tools
+
+
+@pytest.mark.asyncio
+async def test_load_servers_no_filter(mock_registry):
+    """Test that all tools are loaded when no tool filter is specified."""
+    # Create aggregator with no tool filter
+    aggregator = MCPAggregator(mock_registry)
+    
+    # Load the servers
+    await aggregator.load_servers()
+    
+    # Check that all tools were loaded
+    namespaced_tools = list(aggregator._namespaced_tool_map.keys())
+    assert "server1__tool1" in namespaced_tools
+    assert "server1__tool2" in namespaced_tools
+    assert "server1__tool3" in namespaced_tools
+    assert "server2__toolA" in namespaced_tools
+    assert "server2__toolB" in namespaced_tools
+
+
+@pytest.mark.asyncio
+async def test_list_tools_with_filter(mock_registry):
+    """Test that list_tools reflects the tool filtering."""
+    # Create aggregator with tool filter
+    tool_filter = {
+        "server1": ["tool1"],
+        "server2": ["toolA"],
+    }
+    aggregator = MCPAggregator(mock_registry, tool_filter=tool_filter)
+    
+    # Load the servers and list tools
+    await aggregator.load_servers()
+    tools_result = await aggregator.list_tools()
+    
+    # Check that only the filtered tools are included
+    tool_names = [t.name for t in tools_result.tools]
+    assert "server1__tool1" in tool_names
+    assert "server1__tool2" not in tool_names
+    assert "server1__tool3" not in tool_names
+    assert "server2__toolA" in tool_names
+    assert "server2__toolB" not in tool_names
+    assert len(tool_names) == 2
+
+
+@pytest.mark.asyncio
+async def test_list_tools_with_server_mapping_and_filter(mock_registry):
+    """Test that list_tools with server mapping reflects the tool filtering."""
+    # Create aggregator with tool filter
+    tool_filter = {
+        "server1": ["tool1"],
+        "server2": None,  # Include all tools from server2
+    }
+    aggregator = MCPAggregator(mock_registry, tool_filter=tool_filter)
+    
+    # Load the servers and list tools with server mapping
+    await aggregator.load_servers()
+    server_tools = await aggregator.list_tools(return_server_mapping=True)
+    
+    # Check that server mapping contains the right tools
+    assert len(server_tools["server1"]) == 1
+    assert server_tools["server1"][0].name == "tool1"
+    assert len(server_tools["server2"]) == 2
+    assert sorted([t.name for t in server_tools["server2"]]) == ["toolA", "toolB"]
\ No newline at end of file
