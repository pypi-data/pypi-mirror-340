# generated by datamodel-codegen:
#   filename:  sinfo_all.json

from __future__ import annotations

import json
import re
from collections import defaultdict
from typing import NamedTuple

from pydantic import BaseModel


class Number(BaseModel):
    set: bool
    infinite: bool
    number: int

    def __str__(self) -> str:
        if self.infinite:
            return '∞'

        if not self.set:
            return 'NA'

        return str(self.number)


class Groups(BaseModel):
    allowed: str


class Maximums(BaseModel):
    time: Number


class Partition(BaseModel):
    groups: Groups
    maximums: Maximums
    name: str


class Node(BaseModel):
    state: list[str]


class Nodes(BaseModel):
    nodes: list[str]


class SinfoItem(BaseModel):
    node: Node
    nodes: Nodes
    partition: Partition


class PartitionsModel(BaseModel):
    sinfo: list[SinfoItem]


# gemini.google.com:
# Create a python function to convert a list of similar strings
# ['res-hpc-exe001', 'res-hpc-exe003', 'res-hpc-exe009', 'res-hpc-exe012', 'res-hpc-exe024', 'res-hpc-exe027',
# 'res-hpc-exe029', 'res-hpc-exe036', 'res-hpc-exe039', 'res-hpc-exe047', 'res-hpc-exe049', 'res-hpc-exe050',
# 'res-hpc-exe051', 'res-hpc-exe052', 'res-hpc-exe054', 'res-hpc-exe055', 'res-hpc-exe056', 'res-hpc-exe057',
# 'res-hpc-exe058', 'res-hpc-exe059', 'res-hpc-mem02'] to
# ['res-hpc-exe[001,003, 009,012,024,027,029,036,039,047,049-052,054-059]','res-hpc-mem02']


def format_group(prefix: str, numbers: list[int]) -> str:
    """
    Formats a group of numbers into a comma-separated string with ranges.

    Args:
        prefix: The common prefix of the strings.
        numbers: A sorted list of integers.

    Returns:
        A formatted string representing the group.
    """
    if not numbers:
        return prefix  # Should not happen in the main logic

    formatted_parts = []
    i = 0
    while i < len(numbers):
        start = numbers[i]
        end = start
        j = i + 1
        while j < len(numbers) and numbers[j] == end + 1:
            end = numbers[j]
            j += 1

        if start == end:
            formatted_parts.append(f"{start:03d}")  # Ensure 3-digit formatting
        else:
            formatted_parts.append(f"{start:03d}-{end:03d}")  # Ensure 3-digit formatting
        i = j

    return f"{prefix}[{','.join(formatted_parts)}]"


def condense_string_list(string_list: list[str]) -> list[str]:
    """
    Condenses a list of similar strings by grouping consecutive numbers.

    Args:
        string_list: A list of strings with a common prefix and a numerical suffix.

    Returns:
        A list of strings where consecutive numerical suffixes are grouped using a hyphen.
    """
    if not string_list:
        return []

    string_list.sort()  # Sort the list for proper grouping

    grouped_strings = []
    current_prefix = None
    current_numbers = []

    for s in string_list:
        match = re.match(r"([a-zA-Z-]+)(\d+)", s)
        if match:
            prefix = match.group(1)
            number = int(match.group(2))

            if prefix == current_prefix:
                current_numbers.append(number)
            else:
                if current_prefix is not None:
                    grouped_strings.append(format_group(current_prefix, current_numbers))
                current_prefix = prefix
                current_numbers = [number]
        else:
            # Handle strings that don't fit the expected pattern
            if current_prefix is not None:
                grouped_strings.append(format_group(current_prefix, current_numbers))
                current_prefix = None
                current_numbers = []
            grouped_strings.append(s)

    # Add the last group if any
    if current_prefix is not None:
        grouped_strings.append(format_group(current_prefix, current_numbers))

    return grouped_strings


class PartitionInfo(NamedTuple):
    timelimit: Number
    groups: str
    nodes: list[str]


def main() -> None:
    with open('_data/sinfo_all.json', 'r', encoding='utf8') as f:
        data = json.load(f)
        model = PartitionsModel(**data)

    cluster = defaultdict(list)

    for x in model.sinfo:
        groups = x.partition.groups.allowed
        if not groups:
            groups = 'all'

        for state in x.node.state:
            cluster[(x.partition.name, state)].append(PartitionInfo(x.partition.maximums.time, groups, x.nodes.nodes))

    for (name, state), infos in dict(sorted(cluster.items(), key=lambda y: (y[0][0].casefold(), y[0][1]))).items():
        nodes = []
        for info in infos:
            nodes.extend(info.nodes)
        print(f'{name=}, {state=}, timelimit={infos[0].timelimit}, groups={infos[0].groups}, nodes={len(nodes)}, '
              f'nodelist={"〡".join(condense_string_list(nodes))}'
              )


if __name__ == "__main__":
    main()
