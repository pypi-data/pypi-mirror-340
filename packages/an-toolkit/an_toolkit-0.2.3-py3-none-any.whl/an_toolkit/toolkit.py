# -*- coding: utf-8 -*-
"""TLKT_20250403_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1E6xXtrroA_kHmuYZfL0fpYTxLNE_m2NF

# ToolKit
高汎用モジュール集


```
2025/04/02 0.1.0 完成
2025/04/03 0.1.5 小規模修正
2025/04/03 0.2.1 executorメソッドにtimeoutオプションを追加
2025/04/04 0.2.2 バグ取り
```

# ToolKit

## 1. モジュール定義
"""

# @title a.ToolKit 定義
import os
import shutil
import threading
import subprocess
get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper


class ToolKit():
    def __init__( self ):
        """
        ツールキット
        """
        self.debug = DebugHelper( instance_name = "ToolKit" )
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()

    def file_remover( self, target ):
        """
        ファイルを消去します
        args:
            target( str ): 消去するファイルのパス
        """
        if os.path.exists( target ):
            self.debug.log_step(f"{ target } に既存のファイルが存在します。削除します。", success=None, back = 1 )
            try:
                result = subprocess.run(["rm", "-f", target], capture_output=True, text=True)
                # os.remove( target )
                if result.returncode != 0:
                    raise Exception(f"ファイルの削除に失敗しました: {result.stderr}")
                timeout = 5  # 最大5秒待つ
                interval = 0.1  # 0.1秒毎にチェック
                elapsed = 0
                while os.path.exists(target) and elapsed < timeout:
                    time.sleep(interval)
                    elapsed += interval
                if os.path.exists(target):
                    self.debug.log_step(f"{target} の削除がタイムアウトしました。", success=False, back = 1 )
                    raise Exception(f"タイムアウト: {target} が削除されませんでした。")
                self.debug.log_step("既存のファイルを正常に削除しました。", success=True, back = 1)
            except Exception as e:
                self.debug.log_step(f"既存ファイルの削除に失敗しました: {e}", success = False, back = 1 )
                raise

    def dir_remover( self, target ):
        """
        ディレクトリを消去します
        args:
            target( str ): 消去するディレクトリ
        """
        if os.path.exists( target ):
            self.debug.log_step(f"{ target } に既存のディレクトリが存在します。削除します。", success=None, back = 1 )
            try:
                shutil.rmtree( target )
                timeout = 5  # 最大5秒待つ
                interval = 0.1  # 0.1秒毎にチェック
                elapsed = 0
                while os.path.exists(target) and elapsed < timeout:
                    time.sleep(interval)
                    elapsed += interval
                if os.path.exists(target):
                    self.debug.log_step(f"{target} の削除がタイムアウトしました。", success=False, back = 1 )
                    raise Exception(f"タイムアウト: {target} が削除されませんでした。")
                self.debug.log_step("既存のディレクトリを正常に削除しました。", success=True, back = 1 )
            except Exception as e:
                self.debug.log_step(f"既存ディレクトリの削除に失敗しました: {e}", success = False, back = 1 )
                raise

    def executor( self, cmd , shell = False, log = False, timeout = 900 ):
        """
        subprocess.runを用いてコマンドを実行する。
        起動オプションは(1)のとおりに固定。
        状況に適さないならsubprocess.runを使った方が良い。

        (1) check=True, capture_output=True, text=True

        args:
            cmd( str | list [str] ): 実行するコマンド
            shell( bool ) : コマンドの書き方。Trueだと文字列、Falseだと文字配列
            log( bool ) : ログ出力するかどうか
            timeout( int ): タイムアウト時間(秒)
        returns:


        - 参考・subprocess.runのオプション一覧
            - args
            実行するコマンドを指定します。通常は文字列のリスト（例：["ls", "-l"]）ですが、
            shell=True の場合は単一の文字列でも構いません。
            - check
            True にすると、コマンドの終了コードが 0 でない場合に CalledProcessError を
            発生させます。これにより、エラー時に例外処理で捕捉できるようになります。
            - capture_output
            True に設定すると、標準出力（stdout）と標準エラー出力（stderr）がキャプチャ
            され、結果の CompletedProcess オブジェクトの stdout および stderr 属性で
            アクセスできるようになります。
            ※ Python 3.7 以降で使用可能です。
            - text（または universal_newlines）
            True にすると、標準出力および標準エラー出力がバイト列ではなく文字列として返され
            ます。これにより、出力のデコード処理を自前で行う必要がなくなります。
            ※ Python 3.7 以降では text が推奨されます。
            - shell
            True にすると、コマンドがシェル経由で実行されます。これにより、シェルの特殊文字
            やリダイレクト（> など）を使うことができますが、セキュリティ上の注意も必要です。
            - cwd
            コマンド実行時のカレントワーキングディレクトリを指定できます。これを使って、特定
            のディレクトリからコマンドを実行できます。
            - env
            コマンド実行時に使用する環境変数の辞書を指定します。これを設定すると、現在の環境
            とは異なる環境変数を使ってコマンドを実行できます。
            - input
            標準入力に渡すデータを指定します。text=True の場合は文字列、そうでない場合はバ
            イト列を渡します。
            - timeout
            コマンドの実行が指定した秒数を超えた場合に TimeoutExpired エラーを発生させます。
        returns:
            subprocess.CompletedProcess
        """
        self.debug.log_step(f"コマンド: { cmd if shell else ' '.join(cmd) }", success=None, back = 1)

        try:
            result = subprocess.run( cmd, shell = shell, check=True, capture_output=True, text=True )
            self.debug.log_step(f"成功!!!", success=True, back = 1)
            if log:
                self.debug.log_step( f"stdout:\n{ result.stdout }", success = None, back = 1 )
                self.debug.log_step( f"stderr:\n{ result.stderr }", success = None, back = 1 )
            return result
        except subprocess.CalledProcessError as e:
            self.debug.log_step(f"失敗しました。エラーコード: {e.returncode}", success=False, back = 1)
            self.debug.log_step(f"エラーメッセージ: {e.stderr}", success=False, back = 1 )
            raise
        except Exception as e:
            self.debug.log_step(f"予期しないエラーが発生しました: {e}", success=False, back = 1 )
            raise


    def executor_sync(self, cmd, shell=False ):
        """
        sync仕様executor。
        timeoutオプションには対応していません。
        args:
            cmd( str [] ): 実行するコマンド
            shell( bool ) : コマンドの書き方。Trueだと文字列、Falseだと文字配列
        returns:
            subprocess.CompletedProcess
        """
        self.debug.log_step(f"cmd: { cmd }", success=None, back = 1 )

        # Popenでプロセスを起動し、stdout, stderr をリアルタイムに取得する
        process = subprocess.Popen(
            cmd,
            shell=shell,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            bufsize=1,  # 行単位でバッファリング
            universal_newlines=True,
        )

        # stdoutをリアルタイムでログ出力するためのスレッド
        def log_stdout(pipe):
            for line in iter(pipe.readline, ''):
                self.debug.log_step(line.rstrip(), success = None )
            pipe.close()

        # stderrも同様にログ出力する（必要に応じて）
        def log_stderr(pipe):
            for line in iter(pipe.readline, ''):
                self.debug.log_step(f"ERR: {line.rstrip()}", success = None )
            pipe.close()

        stdout_thread = threading.Thread(target=log_stdout, args=(process.stdout,))
        stderr_thread = threading.Thread(target=log_stderr, args=(process.stderr,))
        stdout_thread.start()
        stderr_thread.start()

        # プロセスの終了を待つ
        process.wait()
        stdout_thread.join()
        stderr_thread.join()

        self.debug.log_step( f"result: {process.returncode}", success=None, back = 1 )

        # 完了後、出力をまとめて返す場合は communicate() の代わりに、
        # 今回はすでに各行をログ出力しているので、必要に応じて空文字列などを返す
        if process.returncode == 0:
            self.debug.log_step(f"成功!!!", success=True, back = 1)
            return process
        if process.CalledProcessError:
            self.debug.log_step( f"失敗しました。エラーコード: { process.returncode }", success=False, back = 1)
            raise
        if Exception:
            self.debug.log_step( f"予期しないエラーが発生しました: { process }", success = False, back = 1 )
            raise

"""## 3. テスト"""

# @title ToolKit テスト
if __name__ == "__main__":
    toolkit = ToolKit()
    toolkit.executor_sync( cmd = "pip --version", shell = True )