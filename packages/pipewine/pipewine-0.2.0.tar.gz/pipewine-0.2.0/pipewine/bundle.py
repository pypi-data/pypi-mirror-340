"""`Bundle` class and metaclass for defining bounded dataclasses."""

from abc import ABCMeta
from dataclasses import dataclass
from typing import Any, Generic, Self, TypeVar, dataclass_transform


@dataclass_transform(kw_only_default=True)
class BundleMeta(ABCMeta):
    """Metaclass for `Bundle` classes, which automatically applies the `dataclass`
    decorator on sub-class creation, and explicitly tells the type checker that the
    `Bundle` class behaves like a dataclass, without having to explicitly use the
    `@dataclass` decorator.

    This metaclass is not meant to be used directly, just inheriting from `Bundle` is
    enough to get the desired behavior.
    """

    def __new__(
        cls,
        name: str,
        bases: tuple[type, ...],
        namespace: dict[str, Any],
        /,
        **kwds: Any,
    ):
        the_cls = super().__new__(cls, name, bases, namespace)
        if not kwds.get("_is_root"):
            the_cls = dataclass(the_cls)  # type: ignore
        return the_cls


T = TypeVar("T", covariant=True)


class Bundle(Generic[T], metaclass=BundleMeta, _is_root=True):
    """Base class for all `Bundle` types, which are dataclasses whose fields are
    bounded to a specific type `T`.

    Besides the `as_dict` and `from_dict` methods, `Bundle` classes should not have
    define any other methods, as they are meant to be simple anemic data containers.
    """

    def __init__(self, /, **kwargs: T) -> None:
        """Constructor stub that does nothing, as it will be replaced by the one
        generated by the `dataclass` decorator on sub-class creation.
        """
        pass

    def as_dict(self) -> dict[str, T]:
        """Convert the `Bundle` instance to a plain python dictionary.

        Returns:
            dict[str, T]: A dictionary mapping the field names to their values.
        """
        return self.__dict__

    @classmethod
    def from_dict(cls, **data) -> Self:
        """Create a new `Bundle` instance from a dictionary. This method is supposed to
        be called on the concrete sub-classes, not on the `Bundle` base class for it has
        no fields.
        """
        return cls(**data)

    def __getstate__(self) -> dict[str, T]:
        return self.as_dict()

    def __setstate__(self, data: dict[str, T]) -> None:
        for k, v in data.items():
            setattr(self, k, v)
