"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] = self["webpackChunk_JUPYTERLAB_CORE_OUTPUT"] || []).push([["vendors-node_modules_jupyterlab_mermaid_lib_index_js"],{

/***/ "../node_modules/@jupyterlab/mermaid/lib/index.js":
/*!********************************************************!*\
  !*** ../node_modules/@jupyterlab/mermaid/lib/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DETAILS_CLASS: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.DETAILS_CLASS),\n/* harmony export */   IMermaidManager: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.IMermaidManager),\n/* harmony export */   IMermaidMarkdown: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.IMermaidMarkdown),\n/* harmony export */   MERMAID_CLASS: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.MERMAID_CLASS),\n/* harmony export */   MERMAID_CODE_CLASS: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.MERMAID_CODE_CLASS),\n/* harmony export */   MERMAID_DARK_THEME: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.MERMAID_DARK_THEME),\n/* harmony export */   MERMAID_DEFAULT_THEME: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.MERMAID_DEFAULT_THEME),\n/* harmony export */   MERMAID_FILE_EXTENSIONS: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.MERMAID_FILE_EXTENSIONS),\n/* harmony export */   MERMAID_MIME_TYPE: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.MERMAID_MIME_TYPE),\n/* harmony export */   MermaidManager: () => (/* reexport safe */ _manager__WEBPACK_IMPORTED_MODULE_0__.MermaidManager),\n/* harmony export */   MermaidMarkdown: () => (/* reexport safe */ _markdown__WEBPACK_IMPORTED_MODULE_1__.MermaidMarkdown),\n/* harmony export */   RenderedMermaid: () => (/* reexport safe */ _mime__WEBPACK_IMPORTED_MODULE_2__.RenderedMermaid),\n/* harmony export */   SUMMARY_CLASS: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.SUMMARY_CLASS),\n/* harmony export */   WARNING_CLASS: () => (/* reexport safe */ _tokens__WEBPACK_IMPORTED_MODULE_3__.WARNING_CLASS),\n/* harmony export */   rendererFactory: () => (/* reexport safe */ _mime__WEBPACK_IMPORTED_MODULE_2__.rendererFactory)\n/* harmony export */ });\n/* harmony import */ var _manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./manager */ \"../node_modules/@jupyterlab/mermaid/lib/manager.js\");\n/* harmony import */ var _markdown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./markdown */ \"../node_modules/@jupyterlab/mermaid/lib/markdown.js\");\n/* harmony import */ var _mime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mime */ \"../node_modules/@jupyterlab/mermaid/lib/mime.js\");\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tokens */ \"../node_modules/@jupyterlab/mermaid/lib/tokens.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * @packageDocumentation\n * @module mermaid\n */\n\n\n\n\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/mermaid/lib/index.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/mermaid/lib/manager.js":
/*!**********************************************************!*\
  !*** ../node_modules/@jupyterlab/mermaid/lib/manager.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MermaidManager: () => (/* binding */ MermaidManager)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jupyterlab/coreutils */ \"webpack/sharing/consume/default/@jupyterlab/coreutils/@jupyterlab/coreutils\");\n/* harmony import */ var _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens */ \"../node_modules/@jupyterlab/mermaid/lib/tokens.js\");\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n\n\n/**\n * A mermaid diagram manager with cache.\n */\nclass MermaidManager {\n    constructor(options = {}) {\n        this._diagrams = new _jupyterlab_coreutils__WEBPACK_IMPORTED_MODULE_1__.LruCache({ maxSize: options.maxCacheSize || null });\n        // handle reacting to themes\n        if (options.themes) {\n            Private.initThemes(options.themes || null);\n            options.themes.themeChanged.connect(this.initialize, this);\n        }\n    }\n    /**\n     * Post-process to ensure mermaid diagrams contain only valid SVG and XHTML.\n     */\n    static cleanMermaidSvg(svg) {\n        return svg.replace(Private.RE_VOID_ELEMENT, Private.replaceVoidElement);\n    }\n    /**\n     * Handle (re)-initializing mermaid based on external values.\n     */\n    initialize() {\n        this._diagrams.clear();\n        Private.initMermaid();\n    }\n    /**\n     * Get the underlying, potentially un-initialized mermaid module.\n     */\n    async getMermaid() {\n        return await Private.ensureMermaid();\n    }\n    /**\n     * Get the version of the currently-loaded mermaid module\n     */\n    getMermaidVersion() {\n        return Private.version();\n    }\n    /**\n     * Get a pre-cached mermaid figure.\n     *\n     * This primarily exists for the needs of `marked`, which supports async node\n     * visitors, but not async rendering.\n     */\n    getCachedFigure(text) {\n        return this._diagrams.get(text);\n    }\n    /**\n     * Attempt a raw rendering of mermaid to an SVG string, extracting some metadata.\n     */\n    async renderSvg(text) {\n        const _mermaid = await this.getMermaid();\n        const id = `jp-mermaid-${Private.nextMermaidId()}`;\n        // create temporary element into which to render\n        const el = document.createElement('div');\n        document.body.appendChild(el);\n        try {\n            let { svg } = await _mermaid.render(id, text, el);\n            svg = MermaidManager.cleanMermaidSvg(svg);\n            const parser = new DOMParser();\n            const doc = parser.parseFromString(svg, 'image/svg+xml');\n            const info = { text, svg };\n            const svgEl = doc.querySelector('svg');\n            const { maxWidth } = (svgEl === null || svgEl === void 0 ? void 0 : svgEl.style) || {};\n            info.width = maxWidth ? parseFloat(maxWidth) : null;\n            const firstTitle = doc.querySelector('title');\n            const firstDesc = doc.querySelector('desc');\n            if (firstTitle) {\n                info.accessibleTitle = firstTitle.textContent;\n            }\n            if (firstDesc) {\n                info.accessibleDescription = firstDesc.textContent;\n            }\n            return info;\n        }\n        finally {\n            el.remove();\n        }\n    }\n    /**\n     * Provide and cache a fully-rendered element, checking the cache first.\n     */\n    async renderFigure(text) {\n        // bail if already cached\n        let output = this._diagrams.get(text);\n        if (output != null) {\n            return output;\n        }\n        let className = _tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_CLASS;\n        let result = null;\n        // the element that will be returned\n        output = document.createElement('div');\n        output.className = className;\n        try {\n            const response = await this.renderSvg(text);\n            result = this.makeMermaidFigure(response);\n        }\n        catch (err) {\n            output.classList.add(_tokens__WEBPACK_IMPORTED_MODULE_2__.WARNING_CLASS);\n            result = await this.makeMermaidError(text);\n        }\n        let version = this.getMermaidVersion();\n        if (version) {\n            result.dataset.jpMermaidVersion = version;\n        }\n        output.appendChild(result);\n        // update the cache for use when rendering synchronously\n        this._diagrams.set(text, output);\n        return output;\n    }\n    /**\n     * Provide a code block with the mermaid source.\n     */\n    makeMermaidCode(text) {\n        // append the source\n        const pre = document.createElement('pre');\n        const code = document.createElement('code');\n        code.innerText = text;\n        pre.appendChild(code);\n        code.className = _tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_CODE_CLASS;\n        code.textContent = text;\n        return pre;\n    }\n    /**\n     * Get the parser message element from a failed parse.\n     *\n     * This doesn't do much of anything if the text is successfully parsed.\n     */\n    async makeMermaidError(text) {\n        const _mermaid = await this.getMermaid();\n        let errorMessage = '';\n        try {\n            await _mermaid.parse(text);\n        }\n        catch (err) {\n            errorMessage = `${err}`;\n        }\n        const result = document.createElement('details');\n        result.className = _tokens__WEBPACK_IMPORTED_MODULE_2__.DETAILS_CLASS;\n        const summary = document.createElement('summary');\n        summary.className = _tokens__WEBPACK_IMPORTED_MODULE_2__.SUMMARY_CLASS;\n        summary.appendChild(this.makeMermaidCode(text));\n        result.appendChild(summary);\n        const warning = document.createElement('pre');\n        warning.innerText = errorMessage;\n        result.appendChild(warning);\n        return result;\n    }\n    /**\n     * Extract extra attributes to add to a generated figure.\n     */\n    makeMermaidFigure(info) {\n        const figure = document.createElement('figure');\n        const img = document.createElement('img');\n        figure.appendChild(img);\n        img.setAttribute('src', `data:image/svg+xml,${encodeURIComponent(info.svg)}`);\n        // add dimension information\n        if (info.width) {\n            img.width = info.width;\n        }\n        // add accessible alt title\n        if (info.accessibleTitle) {\n            img.setAttribute('alt', info.accessibleTitle);\n        }\n        figure.appendChild(this.makeMermaidCode(info.text));\n        // add accessible caption, with fallback to raw mermaid source\n        if (info.accessibleDescription) {\n            const caption = document.createElement('figcaption');\n            caption.className = 'sr-only';\n            caption.textContent = info.accessibleDescription;\n            figure.appendChild(caption);\n        }\n        return figure;\n    }\n}\n/**\n * A namespace for global, private mermaid data.\n */\nvar Private;\n(function (Private) {\n    let _themes = null;\n    let _mermaid = null;\n    let _loading = null;\n    let _nextMermaidId = 0;\n    let _version = null;\n    /**\n     * Cache a reference to the theme manager.\n     */\n    function initThemes(themes) {\n        _themes = themes;\n    }\n    Private.initThemes = initThemes;\n    /**\n     * Get the version of mermaid used for rendering.\n     */\n    function version() {\n        return _version;\n    }\n    Private.version = version;\n    /**\n     * (Re-)initialize mermaid with lab-specific theme information\n     */\n    function initMermaid() {\n        if (!_mermaid) {\n            return false;\n        }\n        let theme = _tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_DEFAULT_THEME;\n        if (_themes) {\n            const jpTheme = _themes.theme;\n            theme =\n                jpTheme && _themes.isLight(jpTheme)\n                    ? _tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_DEFAULT_THEME\n                    : _tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_DARK_THEME;\n        }\n        const fontFamily = window\n            .getComputedStyle(document.body)\n            .getPropertyValue('--jp-ui-font-family');\n        _mermaid.mermaidAPI.globalReset();\n        _mermaid.mermaidAPI.initialize({\n            theme,\n            fontFamily,\n            securityLevel: 'strict',\n            maxTextSize: 100000,\n            maxEdges: 100000,\n            startOnLoad: false\n        });\n        return true;\n    }\n    Private.initMermaid = initMermaid;\n    /**\n     * Determine whether mermaid has been loaded yet.\n     */\n    function getMermaid() {\n        return _mermaid;\n    }\n    Private.getMermaid = getMermaid;\n    /**\n     * Provide a globally-unique, but unstable, ID for disambiguation.\n     */\n    function nextMermaidId() {\n        return _nextMermaidId++;\n    }\n    Private.nextMermaidId = nextMermaidId;\n    /**\n     * Ensure mermaid has been lazily loaded once, initialized, and cached.\n     */\n    async function ensureMermaid() {\n        if (_mermaid != null) {\n            return _mermaid;\n        }\n        if (_loading) {\n            return _loading.promise;\n        }\n        _loading = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n        _version = (await __webpack_require__.e(/*! import() */ \"node_modules_mermaid_package_json\").then(__webpack_require__.t.bind(__webpack_require__, /*! mermaid/package.json */ \"../node_modules/mermaid/package.json\", 19))).version;\n        _mermaid = (await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_d3-array_src_deviation_js-node_modules_d3-array_src_intersection_js-node-18c317\"), __webpack_require__.e(\"vendors-node_modules_mermaid_dist_mermaid_core_mjs\")]).then(__webpack_require__.bind(__webpack_require__, /*! mermaid */ \"../node_modules/mermaid/dist/mermaid.core.mjs\"))).default;\n        initMermaid();\n        _loading.resolve(_mermaid);\n        return _mermaid;\n    }\n    Private.ensureMermaid = ensureMermaid;\n    /**\n     * A regular expression for all void elements, which may include attributes and\n     * a slash.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Glossary/Void_element\n     *\n     * Of these, only `<br>` is generated by Mermaid in place of `\\n`,\n     * but _any_ \"malformed\" tag will break the SVG rendering entirely.\n     */\n    Private.RE_VOID_ELEMENT = /<\\s*(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)\\s*([^>]*?)\\s*>/gi;\n    /**\n     * Ensure a void element is closed with a slash, preserving any attributes.\n     */\n    function replaceVoidElement(match, tag, rest) {\n        rest = rest.trim();\n        if (!rest.endsWith('/')) {\n            rest = `${rest} /`;\n        }\n        return `<${tag} ${rest}>`;\n    }\n    Private.replaceVoidElement = replaceVoidElement;\n})(Private || (Private = {}));\n//# sourceMappingURL=manager.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/mermaid/lib/manager.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/mermaid/lib/markdown.js":
/*!***********************************************************!*\
  !*** ../node_modules/@jupyterlab/mermaid/lib/markdown.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MermaidMarkdown: () => (/* binding */ MermaidMarkdown)\n/* harmony export */ });\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/**\n * An implementation of mermaid fenced code blocks in markdown.\n */\nclass MermaidMarkdown {\n    constructor(options) {\n        this.languages = ['mermaid'];\n        this.rank = 100;\n        this._mermaid = options.mermaid;\n    }\n    /**\n     * Pre-parse and cache the rendered text.\n     */\n    async walk(text) {\n        await this._mermaid.renderFigure(text);\n    }\n    /**\n     * Render the diagram.\n     */\n    render(text) {\n        // handle pre-cached mermaid figures\n        let cachedFigure = this._mermaid.getCachedFigure(text);\n        if (cachedFigure) {\n            return cachedFigure.outerHTML;\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=markdown.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/mermaid/lib/markdown.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/mermaid/lib/mime.js":
/*!*******************************************************!*\
  !*** ../node_modules/@jupyterlab/mermaid/lib/mime.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RenderedMermaid: () => (/* binding */ RenderedMermaid),\n/* harmony export */   rendererFactory: () => (/* binding */ rendererFactory)\n/* harmony export */ });\n/* harmony import */ var _tokens__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens */ \"../node_modules/@jupyterlab/mermaid/lib/tokens.js\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lumino/widgets */ \"webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets\");\n/* harmony import */ var _lumino_widgets__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lumino_widgets__WEBPACK_IMPORTED_MODULE_1__);\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\n/**\n * @packageDocumentation\n * @module mermaid-extension\n */\n\n\n\nconst SVG_MIME = 'image/svg+xml';\n/**\n * A widget for rendering mermaid text-based diagrams, for usage with rendermime.\n */\nclass RenderedMermaid extends _lumino_widgets__WEBPACK_IMPORTED_MODULE_1__.Widget {\n    /**\n     * Create a new widget for rendering Vega/Vega-Lite.\n     */\n    constructor(options) {\n        super();\n        this._lastRendered = null;\n        this._mimeType = options.mimeType;\n        this.addClass(_tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_CLASS);\n    }\n    static set manager(manager) {\n        if (RenderedMermaid._manager) {\n            console.warn('Mermaid manager may only be set once, and is already set.');\n            return;\n        }\n        RenderedMermaid._manager = manager;\n        RenderedMermaid._managerReady.resolve(manager);\n    }\n    /**\n     * Render mermaid text-based diagrams into this widget's node.\n     */\n    async renderModel(model) {\n        const manager = await RenderedMermaid._managerReady.promise;\n        const text = model.data[this._mimeType];\n        if (text == null || text === this._lastRendered) {\n            return;\n        }\n        this._lastRendered = text;\n        // get a div containing a figure or parser message\n        const figure = await manager.renderFigure(text);\n        if (figure.classList.contains(_tokens__WEBPACK_IMPORTED_MODULE_2__.WARNING_CLASS)) {\n            this.node.classList.add(_tokens__WEBPACK_IMPORTED_MODULE_2__.WARNING_CLASS);\n        }\n        else {\n            this.node.classList.remove(_tokens__WEBPACK_IMPORTED_MODULE_2__.WARNING_CLASS);\n        }\n        if (!figure.firstChild) {\n            return;\n        }\n        if (this.node.innerHTML !== figure.innerHTML) {\n            this.node.innerHTML = figure.innerHTML;\n        }\n        // capture the version of mermaid used\n        const version = manager.getMermaidVersion();\n        const mermaidMetadata = {\n            ...(model.metadata[_tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_MIME_TYPE] || {}),\n            version\n        };\n        const metadata = {\n            ...model.metadata,\n            [_tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_MIME_TYPE]: mermaidMetadata\n        };\n        // if available, set the fully-rendered SVG\n        const img = figure.querySelector('img');\n        if (img) {\n            const svg = decodeURIComponent(img.src.split(',')[1]);\n            const oldSvg = model.data[SVG_MIME];\n            if (svg !== oldSvg) {\n                model.setData({\n                    data: { ...model.data, [SVG_MIME]: svg },\n                    metadata\n                });\n            }\n        }\n        else {\n            const dataWithoutSvg = { ...model.data };\n            delete dataWithoutSvg[SVG_MIME];\n            model.setData({ data: dataWithoutSvg, metadata });\n        }\n    }\n}\nRenderedMermaid._manager = null;\nRenderedMermaid._managerReady = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.PromiseDelegate();\n/**\n * A mime renderer factory for mermaid text-based diagrams.\n */\nconst rendererFactory = {\n    safe: true,\n    mimeTypes: [_tokens__WEBPACK_IMPORTED_MODULE_2__.MERMAID_MIME_TYPE],\n    createRenderer: options => new RenderedMermaid(options)\n};\n//# sourceMappingURL=mime.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/mermaid/lib/mime.js?");

/***/ }),

/***/ "../node_modules/@jupyterlab/mermaid/lib/tokens.js":
/*!*********************************************************!*\
  !*** ../node_modules/@jupyterlab/mermaid/lib/tokens.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DETAILS_CLASS: () => (/* binding */ DETAILS_CLASS),\n/* harmony export */   IMermaidManager: () => (/* binding */ IMermaidManager),\n/* harmony export */   IMermaidMarkdown: () => (/* binding */ IMermaidMarkdown),\n/* harmony export */   MERMAID_CLASS: () => (/* binding */ MERMAID_CLASS),\n/* harmony export */   MERMAID_CODE_CLASS: () => (/* binding */ MERMAID_CODE_CLASS),\n/* harmony export */   MERMAID_DARK_THEME: () => (/* binding */ MERMAID_DARK_THEME),\n/* harmony export */   MERMAID_DEFAULT_THEME: () => (/* binding */ MERMAID_DEFAULT_THEME),\n/* harmony export */   MERMAID_FILE_EXTENSIONS: () => (/* binding */ MERMAID_FILE_EXTENSIONS),\n/* harmony export */   MERMAID_MIME_TYPE: () => (/* binding */ MERMAID_MIME_TYPE),\n/* harmony export */   SUMMARY_CLASS: () => (/* binding */ SUMMARY_CLASS),\n/* harmony export */   WARNING_CLASS: () => (/* binding */ WARNING_CLASS)\n/* harmony export */ });\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lumino/coreutils */ \"webpack/sharing/consume/default/@lumino/coreutils/@lumino/coreutils\");\n/* harmony import */ var _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__);\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n\n// documented upstream constants\nconst MERMAID_MIME_TYPE = 'text/vnd.mermaid';\nconst MERMAID_FILE_EXTENSIONS = ['.mmd', '.mermaid'];\n// mermaid themes\nconst MERMAID_DEFAULT_THEME = 'default';\nconst MERMAID_DARK_THEME = 'dark';\n// DOM\nconst MERMAID_CLASS = 'jp-RenderedMermaid';\nconst MERMAID_CODE_CLASS = 'mermaid';\nconst WARNING_CLASS = 'jp-mod-warning';\nconst DETAILS_CLASS = 'jp-RenderedMermaid-Details';\nconst SUMMARY_CLASS = 'jp-RenderedMermaid-Summary';\n/**\n * The exported token for a mermaid manager\n */\nconst IMermaidManager = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/mermaid:IMermaidManager', `a manager for rendering mermaid text-based diagrams`);\n/**\n * The exported token for a mermaid manager\n */\nconst IMermaidMarkdown = new _lumino_coreutils__WEBPACK_IMPORTED_MODULE_0__.Token('@jupyterlab/mermaid:IMermaidMarkdown', `a manager for rendering mermaid text-based diagrams in markdown fenced code blocks`);\n//# sourceMappingURL=tokens.js.map\n\n//# sourceURL=webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/mermaid/lib/tokens.js?");

/***/ })

}]);