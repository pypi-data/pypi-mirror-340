# coding: utf-8

"""
    EF Portal REST API

    # Introduction to EF Portal REST API  Welcome to the documentation for the EF Portal REST API, which provides powerful endpoints to manage `GRID`, `MONITOR`, and `SYSTEM` operations.  This comprehensive guide will help you navigate and utilize our API effectively. ## Access Methods  You can interact with the EF Portal through two primary methods:  1. **Web UI**: <a href=\"swagger.html\" target=\"_blank\">Swagger UI</a> to submit commands. **ReDoc** is for documentation purposes.  1. **Command Line Interface**: A Python-based client for programmatic access. - <a href=\"https://pypi.org/project/efpclient/\" target=\"_blank\">EF Portal Client</a> hosted on `PyPi.org`.  Both the Web UI and Python client support all API endpoints described in this documentation. ## API Structure  Our API is organized into three distinct categories for easy navigation and use:  1. **Grid**: Manage hosts, queues, jobs, and clusters. 1. **Monitor**: Access user information and manage licenses (admin-only operations). 1. **System**: Handle services, spoolers, and file operations.  ## Key Operations  ### Grid Operations  - Host and queue management - Job control (find, list, delete, resume, suspend) - Cluster information  ### Monitor Operations (**_Admin Only_**)  - User session management - License control and usage monitoring  ### System Operations  - Service management (list, describe, submit) - Spooler control (list, delete) - File handling (list, upload)  ## OpenAPI Version  You can find the version of OpenAPI spec from the `version` object  ```yaml openapi: 3.0.1   info:   version: '1.0'   title: EF Portal REST API   ...   ```  ## Authentication    The EF Portal REST API uses **token-based** authentication:  - **EF Token**: Your personal access token for API authentication.  ## Getting Started To begin using the API, ensure you have your EF Token ready. Refer to the specific endpoint documentation for detailed usage instructions and examples.   # noqa: E501

    OpenAPI spec version: 1.0
    Contact: info@ni-sp-software.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from efpclient.swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def all_jobs(self, **kwargs):  # noqa: E501
        """Retrieves a list of all jobs currently running on the specified cluster.  # noqa: E501

        **All Jobs Details**<br/><br/>This endpoint performs a GET operation to retrieve all jobs currently running on the specified cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.all_jobs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.all_jobs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.all_jobs_with_http_info(**kwargs)  # noqa: E501
            return data

    def all_jobs_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves a list of all jobs currently running on the specified cluster.  # noqa: E501

        **All Jobs Details**<br/><br/>This endpoint performs a GET operation to retrieve all jobs currently running on the specified cluster.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.all_jobs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method all_jobs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/jobs/all', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Job]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def cancel_job(self, id, **kwargs):  # noqa: E501
        """Terminates a job by specifying its unique ID.  # noqa: E501

        **Cancel Job Details**<br/><br/>This endpoint performs a DELETE operation to cancel a job identified by its unique ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_job(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Job to cancel (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.cancel_job_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.cancel_job_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def cancel_job_with_http_info(self, id, **kwargs):  # noqa: E501
        """Terminates a job by specifying its unique ID.  # noqa: E501

        **Cancel Job Details**<br/><br/>This endpoint performs a DELETE operation to cancel a job identified by its unique ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.cancel_job_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Job to cancel (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `cancel_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/jobs/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def clusters(self, **kwargs):  # noqa: E501
        """Retrieves a list of all clusters currently available.  # noqa: E501

        **List Clusters Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of all available clusters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clusters(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Cluster]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.clusters_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.clusters_with_http_info(**kwargs)  # noqa: E501
            return data

    def clusters_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves a list of all clusters currently available.  # noqa: E501

        **List Clusters Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of all available clusters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.clusters_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Cluster]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method clusters" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/clusters', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Cluster]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_spooler(self, uri, **kwargs):  # noqa: E501
        """Removes a spooler identified by its URI from the system.  # noqa: E501

        This endpoint deletes a spooler identified by its URI from the underlying operating system hosting the EF Portal.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_spooler(uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: URI specifying spooler to delete. (required)
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_spooler_with_http_info(uri, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_spooler_with_http_info(uri, **kwargs)  # noqa: E501
            return data

    def delete_spooler_with_http_info(self, uri, **kwargs):  # noqa: E501
        """Removes a spooler identified by its URI from the system.  # noqa: E501

        This endpoint deletes a spooler identified by its URI from the underlying operating system hosting the EF Portal.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_spooler_with_http_info(uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: URI specifying spooler to delete. (required)
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uri']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_spooler" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `delete_spooler`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'uri' in params:
            query_params.append(('uri', params['uri']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/system/spoolers', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_host(self, name, **kwargs):  # noqa: E501
        """Retrieves detailed information about a host by specifying its name.  # noqa: E501

        **Get Host Details**<br/><br/>This endpoint performs a GET operation to retrieve details about a specific host by its name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_host(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Host to lookup by. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: Host
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_host_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.get_host_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def get_host_with_http_info(self, name, **kwargs):  # noqa: E501
        """Retrieves detailed information about a host by specifying its name.  # noqa: E501

        **Get Host Details**<br/><br/>This endpoint performs a GET operation to retrieve details about a specific host by its name.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_host_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Host to lookup by. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: Host
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `get_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/hosts/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Host',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service(self, sdf, uri, **kwargs):  # noqa: E501
        """Retrieves the service associated with the specified URI from the Service Definition File (SDF).  # noqa: E501

        This endpoint retrieves a service based on its unique URI and the associated Service Definition File (SDF) that contains it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service(sdf, uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sdf: SDF URI containing service to fetch. (required)
        :param str uri: Service URI to fetch. (required)
        :return: Service
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_with_http_info(sdf, uri, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_with_http_info(sdf, uri, **kwargs)  # noqa: E501
            return data

    def get_service_with_http_info(self, sdf, uri, **kwargs):  # noqa: E501
        """Retrieves the service associated with the specified URI from the Service Definition File (SDF).  # noqa: E501

        This endpoint retrieves a service based on its unique URI and the associated Service Definition File (SDF) that contains it.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_with_http_info(sdf, uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sdf: SDF URI containing service to fetch. (required)
        :param str uri: Service URI to fetch. (required)
        :return: Service
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sdf', 'uri']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sdf' is set
        if ('sdf' not in params or
                params['sdf'] is None):
            raise ValueError("Missing the required parameter `sdf` when calling `get_service`")  # noqa: E501
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `get_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sdf' in params:
            query_params.append(('sdf', params['sdf']))  # noqa: E501
        if 'uri' in params:
            query_params.append(('uri', params['uri']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/system/services', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Service',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def hosts(self, **kwargs):  # noqa: E501
        """Retrieves a list of all available hosts.  # noqa: E501

        **List Hosts Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of all available hosts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.hosts(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Host]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.hosts_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.hosts_with_http_info(**kwargs)  # noqa: E501
            return data

    def hosts_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves a list of all available hosts.  # noqa: E501

        **List Hosts Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of all available hosts.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.hosts_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Host]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method hosts" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/hosts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Host]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def job_info(self, id, **kwargs):  # noqa: E501
        """Retrieves detailed information about a job by specifying its unique ID.  # noqa: E501

        **Find Job Details**<br/><br/>This endpoint performs a GET operation to retrieve details about a specific job using its unique ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.job_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Job to look for (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.job_info_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.job_info_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def job_info_with_http_info(self, id, **kwargs):  # noqa: E501
        """Retrieves detailed information about a job by specifying its unique ID.  # noqa: E501

        **Find Job Details**<br/><br/>This endpoint performs a GET operation to retrieve details about a specific job using its unique ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.job_info_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Job to look for (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: Job
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method job_info" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `job_info`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/jobs/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Job',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jobs_by_host(self, name, **kwargs):  # noqa: E501
        """Retrieves a list of all jobs running on the specified host.  # noqa: E501

        **Find Jobs on Host Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of jobs running on a specified host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.jobs_by_host(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Host which jobs to look for. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.jobs_by_host_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.jobs_by_host_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def jobs_by_host_with_http_info(self, name, **kwargs):  # noqa: E501
        """Retrieves a list of all jobs running on the specified host.  # noqa: E501

        **Find Jobs on Host Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of jobs running on a specified host.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.jobs_by_host_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: Host which jobs to look for. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name', 'grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_by_host" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `jobs_by_host`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/jobs/host/{name}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Job]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def jobs_by_spooler(self, uri, **kwargs):  # noqa: E501
        """Retrieves a list of jobs associated with the specified spooler URI.  # noqa: E501

        **Find Jobs in Spooler Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of jobs associated with a specified spooler URI.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.jobs_by_spooler(uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: Spooler containing jobs to look for. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.jobs_by_spooler_with_http_info(uri, **kwargs)  # noqa: E501
        else:
            (data) = self.jobs_by_spooler_with_http_info(uri, **kwargs)  # noqa: E501
            return data

    def jobs_by_spooler_with_http_info(self, uri, **kwargs):  # noqa: E501
        """Retrieves a list of jobs associated with the specified spooler URI.  # noqa: E501

        **Find Jobs in Spooler Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of jobs associated with a specified spooler URI.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.jobs_by_spooler_with_http_info(uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: Spooler containing jobs to look for. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uri', 'grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_by_spooler" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `jobs_by_spooler`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'uri' in params:
            query_params.append(('uri', params['uri']))  # noqa: E501
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/jobs/spooler', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Job]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def licenses(self, **kwargs):  # noqa: E501
        """Provides a summary of the current license usage.  # noqa: E501

        **License Usage Details**<br/><br/>This endpoint performs a GET operation to retrieve license usage information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.licenses(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[License]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.licenses_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.licenses_with_http_info(**kwargs)  # noqa: E501
            return data

    def licenses_with_http_info(self, **kwargs):  # noqa: E501
        """Provides a summary of the current license usage.  # noqa: E501

        **License Usage Details**<br/><br/>This endpoint performs a GET operation to retrieve license usage information.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.licenses_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[License]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method licenses" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/monitor/licenses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[License]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def logout(self, name, **kwargs):  # noqa: E501
        """Logs out a user by specifying their username.  # noqa: E501

        **Force User Logout Details**<br/><br/>This endpoint performs a POST operation to forcibly log out a specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: User to logout identified by name (required)
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.logout_with_http_info(name, **kwargs)  # noqa: E501
        else:
            (data) = self.logout_with_http_info(name, **kwargs)  # noqa: E501
            return data

    def logout_with_http_info(self, name, **kwargs):  # noqa: E501
        """Logs out a user by specifying their username.  # noqa: E501

        **Force User Logout Details**<br/><br/>This endpoint performs a POST operation to forcibly log out a specified user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.logout_with_http_info(name, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str name: User to logout identified by name (required)
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method logout" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'name' is set
        if ('name' not in params or
                params['name'] is None):
            raise ValueError("Missing the required parameter `name` when calling `logout`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'name' in params:
            path_params['name'] = params['name']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/monitor/users/logout/{name}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def my_jobs(self, **kwargs):  # noqa: E501
        """Retrieves a list of jobs owned by the authenticated user.  # noqa: E501

        **List My Jobs Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of jobs owned by the authenticated user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.my_jobs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.my_jobs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.my_jobs_with_http_info(**kwargs)  # noqa: E501
            return data

    def my_jobs_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves a list of jobs owned by the authenticated user.  # noqa: E501

        **List My Jobs Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of jobs owned by the authenticated user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.my_jobs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Job]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method my_jobs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/jobs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Job]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def queues(self, **kwargs):  # noqa: E501
        """Retrieves a list of all available queues.  # noqa: E501

        **List Queues Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of all available queues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.queues(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Queue]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.queues_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.queues_with_http_info(**kwargs)  # noqa: E501
            return data

    def queues_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves a list of all available queues.  # noqa: E501

        **List Queues Details**<br/><br/>This endpoint performs a GET operation to retrieve a list of all available queues.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.queues_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: list[Queue]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method queues" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/queues', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Queue]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def resume_job(self, id, **kwargs):  # noqa: E501
        """Resumes a previously suspended job by specifying its unique ID.  # noqa: E501

        **Resume Job Details**<br/><br/>This endpoint performs a POST operation to resume a previously suspended job using its unique ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_job(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Job to resume. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.resume_job_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.resume_job_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def resume_job_with_http_info(self, id, **kwargs):  # noqa: E501
        """Resumes a previously suspended job by specifying its unique ID.  # noqa: E501

        **Resume Job Details**<br/><br/>This endpoint performs a POST operation to resume a previously suspended job using its unique ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.resume_job_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Job to resume. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method resume_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `resume_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/jobs/resume/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def services(self, sdf, **kwargs):  # noqa: E501
        """Returns a list of all service entries associated with a specified Service Definition File (SDF).  # noqa: E501

        This endpoint returns a list of service entries from a specified Service Definition File (SDF).<br/><br/>**Response**<br/><br/>The response includes key details for each service:<br/><br/>- `ID`: The unique identifier of the service.<br/><br/>- `Name`: The name of the service.<br/><br/>- `URI`: The URI associated with the service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.services(sdf, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sdf: URI of SDF containing services to list. (required)
        :return: list[ServiceEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.services_with_http_info(sdf, **kwargs)  # noqa: E501
        else:
            (data) = self.services_with_http_info(sdf, **kwargs)  # noqa: E501
            return data

    def services_with_http_info(self, sdf, **kwargs):  # noqa: E501
        """Returns a list of all service entries associated with a specified Service Definition File (SDF).  # noqa: E501

        This endpoint returns a list of service entries from a specified Service Definition File (SDF).<br/><br/>**Response**<br/><br/>The response includes key details for each service:<br/><br/>- `ID`: The unique identifier of the service.<br/><br/>- `Name`: The name of the service.<br/><br/>- `URI`: The URI associated with the service.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.services_with_http_info(sdf, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str sdf: URI of SDF containing services to list. (required)
        :return: list[ServiceEntry]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['sdf']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method services" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'sdf' is set
        if ('sdf' not in params or
                params['sdf'] is None):
            raise ValueError("Missing the required parameter `sdf` when calling `services`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'sdf' in params:
            query_params.append(('sdf', params['sdf']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/system/services/all', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[ServiceEntry]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def spooler_files(self, uri, **kwargs):  # noqa: E501
        """Retrieves a list of files in the spooler identified by its URI.  # noqa: E501

        This endpoint allows you to retrieve a list of items stored within a specified spooler.<br/><br/>**Request Details**<br/><br/>- `Spooler URI`: Provide the spooler URI to identify the spooler you want to query.<br/><br/>- `Sub-path`: Optionally specify a sub-path within the spooler to narrow the search. If no sub-path is provided, the root directory of the spooler will be queried.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.spooler_files(uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: URI specifying spooler whose files you want listed. (required)
        :param str sub: Sub-path below path that you want to visit. The root (/) path is used if it is empty.
        :return: list[Item]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.spooler_files_with_http_info(uri, **kwargs)  # noqa: E501
        else:
            (data) = self.spooler_files_with_http_info(uri, **kwargs)  # noqa: E501
            return data

    def spooler_files_with_http_info(self, uri, **kwargs):  # noqa: E501
        """Retrieves a list of files in the spooler identified by its URI.  # noqa: E501

        This endpoint allows you to retrieve a list of items stored within a specified spooler.<br/><br/>**Request Details**<br/><br/>- `Spooler URI`: Provide the spooler URI to identify the spooler you want to query.<br/><br/>- `Sub-path`: Optionally specify a sub-path within the spooler to narrow the search. If no sub-path is provided, the root directory of the spooler will be queried.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.spooler_files_with_http_info(uri, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str uri: URI specifying spooler whose files you want listed. (required)
        :param str sub: Sub-path below path that you want to visit. The root (/) path is used if it is empty.
        :return: list[Item]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['uri', 'sub']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method spooler_files" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'uri' is set
        if ('uri' not in params or
                params['uri'] is None):
            raise ValueError("Missing the required parameter `uri` when calling `spooler_files`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'uri' in params:
            query_params.append(('uri', params['uri']))  # noqa: E501
        if 'sub' in params:
            query_params.append(('sub', params['sub']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/system/spoolers/files', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Item]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def spoolers(self, **kwargs):  # noqa: E501
        """Retrieves a list of spoolers owned by the authenticated user.  # noqa: E501

        This endpoint retrieves a list of spoolers owned by the authenticated user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.spoolers(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Spooler]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.spoolers_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.spoolers_with_http_info(**kwargs)  # noqa: E501
            return data

    def spoolers_with_http_info(self, **kwargs):  # noqa: E501
        """Retrieves a list of spoolers owned by the authenticated user.  # noqa: E501

        This endpoint retrieves a list of spoolers owned by the authenticated user.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.spoolers_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Spooler]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method spoolers" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/system/spoolers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Spooler]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def submit_service(self, body, **kwargs):  # noqa: E501
        """Allows you to submit a service to the EF Portal for processing.  # noqa: E501

        This endpoint allows you to submit a service by posting a JSON request.<br/><br/>**Request Details**<br/><br/>The JSON payload must include:<br/><br/>- `SDF`: The Service Definition File describing the service.<br/><br/>- `URI`: The unique identifier defining the service.<br/><br/>- `Options`: Any additional options required for submitting the service.<br/><br/>**Handling Local Files**<br/><br/>- If the service requires one or more local files, upload them to a spooler first using the `/rest/system/spoolers/upload/{filename}` endpoint.<br/>- Once uploaded, include the resulting spooler URI in the `spoolerUri` field of the JSON payload.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.submit_service(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceRequest body: Contains SDF, service URI, service options and spooler URI to reuse. (required)
        :return: ServiceSubmissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.submit_service_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.submit_service_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def submit_service_with_http_info(self, body, **kwargs):  # noqa: E501
        """Allows you to submit a service to the EF Portal for processing.  # noqa: E501

        This endpoint allows you to submit a service by posting a JSON request.<br/><br/>**Request Details**<br/><br/>The JSON payload must include:<br/><br/>- `SDF`: The Service Definition File describing the service.<br/><br/>- `URI`: The unique identifier defining the service.<br/><br/>- `Options`: Any additional options required for submitting the service.<br/><br/>**Handling Local Files**<br/><br/>- If the service requires one or more local files, upload them to a spooler first using the `/rest/system/spoolers/upload/{filename}` endpoint.<br/>- Once uploaded, include the resulting spooler URI in the `spoolerUri` field of the JSON payload.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.submit_service_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ServiceRequest body: Contains SDF, service URI, service options and spooler URI to reuse. (required)
        :return: ServiceSubmissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method submit_service" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `submit_service`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/system/services', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceSubmissionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def suspend_job(self, id, **kwargs):  # noqa: E501
        """Pauses an active job by specifying its unique ID.  # noqa: E501

        **Suspend Job Details**<br/><br/>This endpoint performs a POST operation to suspend an active job using its unique ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.suspend_job(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Job to suspend. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.suspend_job_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.suspend_job_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def suspend_job_with_http_info(self, id, **kwargs):  # noqa: E501
        """Pauses an active job by specifying its unique ID.  # noqa: E501

        **Suspend Job Details**<br/><br/>This endpoint performs a POST operation to suspend an active job using its unique ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.suspend_job_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Job to suspend. (required)
        :param str grid: HPC scheduler or VDI session manager to use. Not specifying this value means the default is used.
        :param str cluster: Cluster to use. Not specifying this value means the default is used.
        :return: RestResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'grid', 'cluster']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method suspend_job" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `suspend_job`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'grid' in params:
            query_params.append(('grid', params['grid']))  # noqa: E501
        if 'cluster' in params:
            query_params.append(('cluster', params['cluster']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/grid/jobs/suspend/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='RestResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def upload_file(self, body, filename, **kwargs):  # noqa: E501
        """Streams a file into the specified spooler.  # noqa: E501

        This endpoint allows you to stream-upload a single file into a spooler.<br/><br/>**Request Details**<br/><br/>- `Spooler URI`: Specify the spooler URI using the custom `spooler` header. If this header is omitted, a new spooler will be created with a default expiration of `1 day`.<br/><br/>- `Sub-path`: Optionally, specify a sub-path within the spooler using the custom `path` header. If this header is omitted, the file will be uploaded to the spoolers root directory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file(body, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object body: File content to upload as a stream (required)
        :param str filename: Name of the file to upload (required)
        :return: ServiceSubmissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.upload_file_with_http_info(body, filename, **kwargs)  # noqa: E501
        else:
            (data) = self.upload_file_with_http_info(body, filename, **kwargs)  # noqa: E501
            return data

    def upload_file_with_http_info(self, body, filename, **kwargs):  # noqa: E501
        """Streams a file into the specified spooler.  # noqa: E501

        This endpoint allows you to stream-upload a single file into a spooler.<br/><br/>**Request Details**<br/><br/>- `Spooler URI`: Specify the spooler URI using the custom `spooler` header. If this header is omitted, a new spooler will be created with a default expiration of `1 day`.<br/><br/>- `Sub-path`: Optionally, specify a sub-path within the spooler using the custom `path` header. If this header is omitted, the file will be uploaded to the spoolers root directory.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.upload_file_with_http_info(body, filename, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param object body: File content to upload as a stream (required)
        :param str filename: Name of the file to upload (required)
        :return: ServiceSubmissionResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'filename']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method upload_file" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `upload_file`")  # noqa: E501
        # verify the required parameter 'filename' is set
        if ('filename' not in params or
                params['filename'] is None):
            raise ValueError("Missing the required parameter `filename` when calling `upload_file`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'filename' in params:
            path_params['filename'] = params['filename']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/system/spoolers/upload/{filename}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ServiceSubmissionResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def users(self, **kwargs):  # noqa: E501
        """Displays a list of all users currently logged into the system.  # noqa: E501

        **Logged-In Users Details**<br/><br/>This endpoint performs a GET operation to retrieve information about users currently logged into the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Session]
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.users_with_http_info(**kwargs)  # noqa: E501
            return data

    def users_with_http_info(self, **kwargs):  # noqa: E501
        """Displays a list of all users currently logged into the system.  # noqa: E501

        **Logged-In Users Details**<br/><br/>This endpoint performs a GET operation to retrieve information about users currently logged into the system.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: list[Session]
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['eftoken']  # noqa: E501

        return self.api_client.call_api(
            '/rest/monitor/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='list[Session]',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
