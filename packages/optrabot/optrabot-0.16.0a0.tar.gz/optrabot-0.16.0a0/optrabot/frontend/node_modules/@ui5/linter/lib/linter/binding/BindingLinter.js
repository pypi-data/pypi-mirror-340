import { MESSAGE } from "../messages.js";
import BindingParser from "./lib/BindingParser.js";
export default class BindingLinter {
    #resourcePath;
    #context;
    constructor(resourcePath, context) {
        this.#resourcePath = resourcePath;
        this.#context = context;
    }
    #parseBinding(binding) {
        const bindingInfo = BindingParser.complexParser(binding, null, true, true, true, true);
        return bindingInfo;
    }
    #analyzeCommonBindingParts(bindingInfo, requireDeclarations, position) {
        const { events } = bindingInfo;
        if (events && typeof events === "object") {
            for (const eventHandler of Object.values(events)) {
                this.#checkForGlobalReference(eventHandler, requireDeclarations, position);
            }
        }
    }
    #analyzePropertyBinding(bindingInfo, requireDeclarations, position) {
        this.#analyzeCommonBindingParts(bindingInfo, requireDeclarations, position);
        const { formatter, type } = bindingInfo;
        if (formatter) {
            if (Array.isArray(formatter)) {
                formatter.forEach((formatterItem) => {
                    this.#checkForGlobalReference(formatterItem, requireDeclarations, position);
                });
            }
            else {
                this.#checkForGlobalReference(formatter, requireDeclarations, position);
            }
        }
        if (type) {
            this.#checkForGlobalReference(type, requireDeclarations, position);
        }
    }
    #analyzeAggregationBinding(bindingInfo, requireDeclarations, position) {
        this.#analyzeCommonBindingParts(bindingInfo, requireDeclarations, position);
        const { factory, groupHeaderFactory, filters, sorter } = bindingInfo;
        if (factory) {
            this.#checkForGlobalReference(factory, requireDeclarations, position);
        }
        if (groupHeaderFactory) {
            this.#checkForGlobalReference(groupHeaderFactory, requireDeclarations, position);
        }
        if (filters) {
            this.#analyzeFilters(filters, requireDeclarations, position);
        }
        if (sorter) {
            this.#analyzeSorter(sorter, requireDeclarations, position);
        }
    }
    #analyzeFilters(filters, requireDeclarations, position) {
        if (Array.isArray(filters)) {
            for (const filter of filters) {
                this.#analyzeFilters(filter, requireDeclarations, position);
            }
            return;
        }
        const { test, filters: nestedFilters, condition } = filters;
        if (test) {
            this.#checkForGlobalReference(test, requireDeclarations, position);
        }
        if (nestedFilters) {
            this.#analyzeFilters(nestedFilters, requireDeclarations, position);
        }
        if (condition) {
            this.#analyzeFilters(condition, requireDeclarations, position);
        }
    }
    #analyzeSorter(sorter, requireDeclarations, position) {
        if (Array.isArray(sorter)) {
            for (const sorterItem of sorter) {
                this.#analyzeSorter(sorterItem, requireDeclarations, position);
            }
            return;
        }
        const { group, comparator } = sorter;
        if (group && typeof group !== "boolean") {
            this.#checkForGlobalReference(group, requireDeclarations, position);
        }
        if (comparator) {
            this.#checkForGlobalReference(comparator, requireDeclarations, position);
        }
    }
    #checkForGlobalReference(ref, requireDeclarations, position) {
        if (ref.startsWith(".")) {
            // Ignore empty reference or reference to the controller (as indicated by the leading dot)
            return false;
        }
        const parts = ref.split(".");
        let variableName;
        if (parts.length) {
            variableName = parts[0];
        }
        else {
            variableName = ref;
        }
        const requireDeclaration = requireDeclarations.find((decl) => decl.variableName === variableName ||
            decl.moduleName === parts.join("/"));
        if (requireDeclaration) {
            return false;
        }
        // Global reference detected
        this.#context.addLintingMessage(this.#resourcePath, MESSAGE.NO_GLOBALS, {
            variableName,
            namespace: ref,
        }, position);
    }
    lintPropertyBinding(bindingDefinition, requireDeclarations, position) {
        try {
            const bindingInfo = this.#parseBinding(bindingDefinition);
            if (bindingInfo) {
                this.#analyzePropertyBinding(bindingInfo, requireDeclarations, position);
            }
        }
        catch (err) {
            const message = err instanceof Error ? err.message : String(err);
            this.#context.addLintingMessage(this.#resourcePath, MESSAGE.PARSING_ERROR, { message }, position);
        }
    }
    lintAggregationBinding(bindingDefinition, requireDeclarations, position) {
        try {
            const bindingInfo = this.#parseBinding(bindingDefinition);
            if (bindingInfo) {
                this.#analyzeAggregationBinding(bindingInfo, requireDeclarations, position);
            }
        }
        catch (err) {
            const message = err instanceof Error ? err.message : String(err);
            this.#context.addLintingMessage(this.#resourcePath, MESSAGE.PARSING_ERROR, { message }, position);
        }
    }
    #isExpressionBinding(bindingDefinition) {
        return /^\{:?=/.test(bindingDefinition) && bindingDefinition.endsWith("}");
    }
    lintPropertyExpression(bindingDefinition, requireDeclarations, position) {
        if (!this.#isExpressionBinding(bindingDefinition)) {
            return;
        }
        const allFunctionsModule = "sap/ui/model/odata/ODataExpressionAddons";
        const varModuleMap = {
            "odata.compare": "sap/ui/model/odata/v4/ODataUtils",
            "odata.fillUriTemplate": "sap/ui/thirdparty/URITemplate",
            "odata.uriEncode": "sap/ui/model/odata/ODataUtils",
        };
        for (const [key, value] of Object.entries(varModuleMap)) {
            if (bindingDefinition.includes(`${key}(`) &&
                !requireDeclarations.some((decl) => decl.moduleName === value || value === allFunctionsModule)) {
                this.#context.addLintingMessage(this.#resourcePath, MESSAGE.NO_ODATA_GLOBALS, {}, position);
            }
        }
    }
}
//# sourceMappingURL=BindingLinter.js.map