# This file was auto-generated by Fern from our API Definition.

import typing
from ..core.client_wrapper import SyncClientWrapper
from ..core.request_options import RequestOptions
from .types.list_syncs_sync_get_response import ListSyncsSyncGetResponse
from ..core.pydantic_utilities import parse_obj_as
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.http_validation_error import HttpValidationError
from json.decoder import JSONDecodeError
from ..core.api_error import ApiError
import datetime as dt
from ..types.sync_status import SyncStatus
from ..types.sync import Sync
from ..types.sync_job import SyncJob
from ..core.jsonable_encoder import jsonable_encoder
from ..types.sync_dag import SyncDag
from ..core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class SyncClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list_syncs(
        self,
        *,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        with_source_connection: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListSyncsSyncGetResponse:
        """
        List all syncs for the current user.

        Args:
        -----
            db: The database session
            skip: The number of syncs to skip
            limit: The number of syncs to return
            with_source_connection: Whether to include the source connection in the response
            user: The current user

        Returns:
        --------
            list[schemas.Sync] | list[schemas.SyncWithSourceConnection]: A list of syncs

        Parameters
        ----------
        skip : typing.Optional[int]

        limit : typing.Optional[int]

        with_source_connection : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListSyncsSyncGetResponse
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.list_syncs()
        """
        _response = self._client_wrapper.httpx_client.request(
            "sync/",
            method="GET",
            params={
                "skip": skip,
                "limit": limit,
                "with_source_connection": with_source_connection,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListSyncsSyncGetResponse,
                    parse_obj_as(
                        type_=ListSyncsSyncGetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create_sync(
        self,
        *,
        name: str,
        source_connection_id: str,
        destination_connection_ids: typing.Sequence[str],
        embedding_model_connection_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        cron_schedule: typing.Optional[str] = OMIT,
        next_scheduled_run: typing.Optional[dt.datetime] = OMIT,
        white_label_id: typing.Optional[str] = OMIT,
        white_label_user_identifier: typing.Optional[str] = OMIT,
        sync_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        status: typing.Optional[SyncStatus] = OMIT,
        run_immediately: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sync:
        """
        Create a new sync configuration.

        Args:
        -----
            db: The database session
            sync_in: The sync to create
            user: The current user
            background_tasks: The background tasks

        Returns:
        --------
            sync (schemas.Sync): The created sync

        Parameters
        ----------
        name : str

        source_connection_id : str

        destination_connection_ids : typing.Sequence[str]

        embedding_model_connection_id : typing.Optional[str]

        description : typing.Optional[str]

        cron_schedule : typing.Optional[str]

        next_scheduled_run : typing.Optional[dt.datetime]

        white_label_id : typing.Optional[str]

        white_label_user_identifier : typing.Optional[str]

        sync_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        status : typing.Optional[SyncStatus]

        run_immediately : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sync
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.create_sync(
            name="name",
            source_connection_id="source_connection_id",
            destination_connection_ids=["destination_connection_ids"],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "sync/",
            method="POST",
            json={
                "name": name,
                "source_connection_id": source_connection_id,
                "embedding_model_connection_id": embedding_model_connection_id,
                "destination_connection_ids": destination_connection_ids,
                "description": description,
                "cron_schedule": cron_schedule,
                "next_scheduled_run": next_scheduled_run,
                "white_label_id": white_label_id,
                "white_label_user_identifier": white_label_user_identifier,
                "sync_metadata": sync_metadata,
                "status": status,
                "run_immediately": run_immediately,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sync,
                    parse_obj_as(
                        type_=Sync,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_all_jobs(
        self,
        *,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[SyncJob]:
        """
        List all sync jobs across all syncs.

        Args:
        -----
            db: The database session
            skip: The number of jobs to skip
            limit: The number of jobs to return
            user: The current user

        Returns:
        --------
            list[schemas.SyncJob]: A list of all sync jobs

        Parameters
        ----------
        skip : typing.Optional[int]

        limit : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[SyncJob]
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.list_all_jobs()
        """
        _response = self._client_wrapper.httpx_client.request(
            "sync/jobs",
            method="GET",
            params={
                "skip": skip,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[SyncJob],
                    parse_obj_as(
                        type_=typing.List[SyncJob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_sync(self, sync_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Sync:
        """
        Get a specific sync by ID.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to get
            user: The current user

        Returns:
        --------
            sync (schemas.Sync): The sync

        Parameters
        ----------
        sync_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sync
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.get_sync(
            sync_id="sync_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sync,
                    parse_obj_as(
                        type_=Sync,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete_sync(
        self,
        sync_id: str,
        *,
        delete_data: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sync:
        """
        Delete a sync configuration and optionally its associated data.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to delete
            delete_data: Whether to delete the data associated with the sync
            user: The current user

        Returns:
        --------
            sync (schemas.Sync): The deleted sync

        Parameters
        ----------
        sync_id : str

        delete_data : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sync
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.delete_sync(
            sync_id="sync_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}",
            method="DELETE",
            params={
                "delete_data": delete_data,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sync,
                    parse_obj_as(
                        type_=Sync,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update_sync(
        self,
        sync_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        cron_schedule: typing.Optional[str] = OMIT,
        next_scheduled_run: typing.Optional[dt.datetime] = OMIT,
        white_label_id: typing.Optional[str] = OMIT,
        white_label_user_identifier: typing.Optional[str] = OMIT,
        sync_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        status: typing.Optional[SyncStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sync:
        """
        Update a sync configuration.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to update
            sync_update: The sync update data
            user: The current user

        Returns:
        --------
            sync (schemas.Sync): The updated sync

        Parameters
        ----------
        sync_id : str

        name : typing.Optional[str]

        cron_schedule : typing.Optional[str]

        next_scheduled_run : typing.Optional[dt.datetime]

        white_label_id : typing.Optional[str]

        white_label_user_identifier : typing.Optional[str]

        sync_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        status : typing.Optional[SyncStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sync
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.update_sync(
            sync_id="sync_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}",
            method="PATCH",
            json={
                "name": name,
                "cron_schedule": cron_schedule,
                "next_scheduled_run": next_scheduled_run,
                "white_label_id": white_label_id,
                "white_label_user_identifier": white_label_user_identifier,
                "sync_metadata": sync_metadata,
                "status": status,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sync,
                    parse_obj_as(
                        type_=Sync,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def run_sync(self, sync_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> SyncJob:
        """
        Trigger a sync run.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to run
            user: The current user
            background_tasks: The background tasks

        Returns:
        --------
            sync_job (schemas.SyncJob): The sync job

        Parameters
        ----------
        sync_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncJob
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.run_sync(
            sync_id="sync_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}/run",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SyncJob,
                    parse_obj_as(
                        type_=SyncJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def list_sync_jobs(
        self, sync_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[SyncJob]:
        """
        List all jobs for a specific sync.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to list jobs for
            user: The current user

        Returns:
        --------
            list[schemas.SyncJob]: A list of sync jobs

        Parameters
        ----------
        sync_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[SyncJob]
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.list_sync_jobs(
            sync_id="sync_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}/jobs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[SyncJob],
                    parse_obj_as(
                        type_=typing.List[SyncJob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_sync_job(
        self, sync_id: str, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SyncJob:
        """
        Get details of a specific sync job.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to list jobs for
            job_id: The ID of the job to get
            user: The current user

        Returns:
        --------
            sync_job (schemas.SyncJob): The sync job

        Parameters
        ----------
        sync_id : str

        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncJob
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.get_sync_job(
            sync_id="sync_id",
            job_id="job_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}/job/{jsonable_encoder(job_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SyncJob,
                    parse_obj_as(
                        type_=SyncJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def subscribe_sync_job(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Server-Sent Events (SSE) endpoint to subscribe to a sync job's progress.

        Args:
        -----
            job_id: The ID of the job to subscribe to
            user: The current user

        Returns:
        --------
            StreamingResponse: The streaming response

        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.subscribe_sync_job(
            job_id="job_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sync/job/{jsonable_encoder(job_id)}/subscribe",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get_sync_dag(self, sync_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> SyncDag:
        """
        Get the DAG for a specific sync.

        Parameters
        ----------
        sync_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncDag
            Successful Response

        Examples
        --------
        from airweave import AirweaveSDK

        client = AirweaveSDK(
            api_key="YOUR_API_KEY",
        )
        client.sync.get_sync_dag(
            sync_id="sync_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}/dag",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SyncDag,
                    parse_obj_as(
                        type_=SyncDag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncSyncClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list_syncs(
        self,
        *,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        with_source_connection: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ListSyncsSyncGetResponse:
        """
        List all syncs for the current user.

        Args:
        -----
            db: The database session
            skip: The number of syncs to skip
            limit: The number of syncs to return
            with_source_connection: Whether to include the source connection in the response
            user: The current user

        Returns:
        --------
            list[schemas.Sync] | list[schemas.SyncWithSourceConnection]: A list of syncs

        Parameters
        ----------
        skip : typing.Optional[int]

        limit : typing.Optional[int]

        with_source_connection : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ListSyncsSyncGetResponse
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.list_syncs()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sync/",
            method="GET",
            params={
                "skip": skip,
                "limit": limit,
                "with_source_connection": with_source_connection,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    ListSyncsSyncGetResponse,
                    parse_obj_as(
                        type_=ListSyncsSyncGetResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create_sync(
        self,
        *,
        name: str,
        source_connection_id: str,
        destination_connection_ids: typing.Sequence[str],
        embedding_model_connection_id: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        cron_schedule: typing.Optional[str] = OMIT,
        next_scheduled_run: typing.Optional[dt.datetime] = OMIT,
        white_label_id: typing.Optional[str] = OMIT,
        white_label_user_identifier: typing.Optional[str] = OMIT,
        sync_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        status: typing.Optional[SyncStatus] = OMIT,
        run_immediately: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sync:
        """
        Create a new sync configuration.

        Args:
        -----
            db: The database session
            sync_in: The sync to create
            user: The current user
            background_tasks: The background tasks

        Returns:
        --------
            sync (schemas.Sync): The created sync

        Parameters
        ----------
        name : str

        source_connection_id : str

        destination_connection_ids : typing.Sequence[str]

        embedding_model_connection_id : typing.Optional[str]

        description : typing.Optional[str]

        cron_schedule : typing.Optional[str]

        next_scheduled_run : typing.Optional[dt.datetime]

        white_label_id : typing.Optional[str]

        white_label_user_identifier : typing.Optional[str]

        sync_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        status : typing.Optional[SyncStatus]

        run_immediately : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sync
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.create_sync(
                name="name",
                source_connection_id="source_connection_id",
                destination_connection_ids=["destination_connection_ids"],
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sync/",
            method="POST",
            json={
                "name": name,
                "source_connection_id": source_connection_id,
                "embedding_model_connection_id": embedding_model_connection_id,
                "destination_connection_ids": destination_connection_ids,
                "description": description,
                "cron_schedule": cron_schedule,
                "next_scheduled_run": next_scheduled_run,
                "white_label_id": white_label_id,
                "white_label_user_identifier": white_label_user_identifier,
                "sync_metadata": sync_metadata,
                "status": status,
                "run_immediately": run_immediately,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sync,
                    parse_obj_as(
                        type_=Sync,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_all_jobs(
        self,
        *,
        skip: typing.Optional[int] = None,
        limit: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.List[SyncJob]:
        """
        List all sync jobs across all syncs.

        Args:
        -----
            db: The database session
            skip: The number of jobs to skip
            limit: The number of jobs to return
            user: The current user

        Returns:
        --------
            list[schemas.SyncJob]: A list of all sync jobs

        Parameters
        ----------
        skip : typing.Optional[int]

        limit : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[SyncJob]
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.list_all_jobs()


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "sync/jobs",
            method="GET",
            params={
                "skip": skip,
                "limit": limit,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[SyncJob],
                    parse_obj_as(
                        type_=typing.List[SyncJob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_sync(self, sync_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> Sync:
        """
        Get a specific sync by ID.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to get
            user: The current user

        Returns:
        --------
            sync (schemas.Sync): The sync

        Parameters
        ----------
        sync_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sync
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.get_sync(
                sync_id="sync_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sync,
                    parse_obj_as(
                        type_=Sync,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete_sync(
        self,
        sync_id: str,
        *,
        delete_data: typing.Optional[bool] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sync:
        """
        Delete a sync configuration and optionally its associated data.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to delete
            delete_data: Whether to delete the data associated with the sync
            user: The current user

        Returns:
        --------
            sync (schemas.Sync): The deleted sync

        Parameters
        ----------
        sync_id : str

        delete_data : typing.Optional[bool]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sync
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.delete_sync(
                sync_id="sync_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}",
            method="DELETE",
            params={
                "delete_data": delete_data,
            },
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sync,
                    parse_obj_as(
                        type_=Sync,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update_sync(
        self,
        sync_id: str,
        *,
        name: typing.Optional[str] = OMIT,
        cron_schedule: typing.Optional[str] = OMIT,
        next_scheduled_run: typing.Optional[dt.datetime] = OMIT,
        white_label_id: typing.Optional[str] = OMIT,
        white_label_user_identifier: typing.Optional[str] = OMIT,
        sync_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        status: typing.Optional[SyncStatus] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Sync:
        """
        Update a sync configuration.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to update
            sync_update: The sync update data
            user: The current user

        Returns:
        --------
            sync (schemas.Sync): The updated sync

        Parameters
        ----------
        sync_id : str

        name : typing.Optional[str]

        cron_schedule : typing.Optional[str]

        next_scheduled_run : typing.Optional[dt.datetime]

        white_label_id : typing.Optional[str]

        white_label_user_identifier : typing.Optional[str]

        sync_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        status : typing.Optional[SyncStatus]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Sync
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.update_sync(
                sync_id="sync_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}",
            method="PATCH",
            json={
                "name": name,
                "cron_schedule": cron_schedule,
                "next_scheduled_run": next_scheduled_run,
                "white_label_id": white_label_id,
                "white_label_user_identifier": white_label_user_identifier,
                "sync_metadata": sync_metadata,
                "status": status,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    Sync,
                    parse_obj_as(
                        type_=Sync,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def run_sync(self, sync_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> SyncJob:
        """
        Trigger a sync run.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to run
            user: The current user
            background_tasks: The background tasks

        Returns:
        --------
            sync_job (schemas.SyncJob): The sync job

        Parameters
        ----------
        sync_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncJob
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.run_sync(
                sync_id="sync_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}/run",
            method="POST",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SyncJob,
                    parse_obj_as(
                        type_=SyncJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def list_sync_jobs(
        self, sync_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.List[SyncJob]:
        """
        List all jobs for a specific sync.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to list jobs for
            user: The current user

        Returns:
        --------
            list[schemas.SyncJob]: A list of sync jobs

        Parameters
        ----------
        sync_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.List[SyncJob]
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.list_sync_jobs(
                sync_id="sync_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}/jobs",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.List[SyncJob],
                    parse_obj_as(
                        type_=typing.List[SyncJob],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_sync_job(
        self, sync_id: str, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> SyncJob:
        """
        Get details of a specific sync job.

        Args:
        -----
            db: The database session
            sync_id: The ID of the sync to list jobs for
            job_id: The ID of the job to get
            user: The current user

        Returns:
        --------
            sync_job (schemas.SyncJob): The sync job

        Parameters
        ----------
        sync_id : str

        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncJob
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.get_sync_job(
                sync_id="sync_id",
                job_id="job_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}/job/{jsonable_encoder(job_id)}",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SyncJob,
                    parse_obj_as(
                        type_=SyncJob,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def subscribe_sync_job(
        self, job_id: str, *, request_options: typing.Optional[RequestOptions] = None
    ) -> typing.Optional[typing.Any]:
        """
        Server-Sent Events (SSE) endpoint to subscribe to a sync job's progress.

        Args:
        -----
            job_id: The ID of the job to subscribe to
            user: The current user

        Returns:
        --------
            StreamingResponse: The streaming response

        Parameters
        ----------
        job_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.subscribe_sync_job(
                job_id="job_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sync/job/{jsonable_encoder(job_id)}/subscribe",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get_sync_dag(self, sync_id: str, *, request_options: typing.Optional[RequestOptions] = None) -> SyncDag:
        """
        Get the DAG for a specific sync.

        Parameters
        ----------
        sync_id : str

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncDag
            Successful Response

        Examples
        --------
        import asyncio

        from airweave import AsyncAirweaveSDK

        client = AsyncAirweaveSDK(
            api_key="YOUR_API_KEY",
        )


        async def main() -> None:
            await client.sync.get_sync_dag(
                sync_id="sync_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"sync/{jsonable_encoder(sync_id)}/dag",
            method="GET",
            request_options=request_options,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    SyncDag,
                    parse_obj_as(
                        type_=SyncDag,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    typing.cast(
                        HttpValidationError,
                        parse_obj_as(
                            type_=HttpValidationError,  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)
