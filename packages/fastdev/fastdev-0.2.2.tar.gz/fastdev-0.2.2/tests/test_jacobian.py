import torch

from fastdev.robo.articulation import Articulation, ArticulationSpec


def _run_jacobian_tests(use_warp: bool = True) -> None:
    """Run jacobian tests for various articulations."""
    device: str = "cuda" if torch.cuda.is_available() else "cpu"
    maybe_kwargs = {} if use_warp is None else {"use_warp": use_warp}

    # test single kuka_iiwa
    joint_values = torch.tensor([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7], device=device)
    arti = Articulation.from_urdf_or_mjcf_path("assets/robot_description/kuka_iiwa.urdf", device=device)
    J = arti.jacobian(joint_values, clamp_joint_values=False, **maybe_kwargs)
    # fmt: off
    J_expected = torch.tensor([
        [0.01874709501862526, 0.8727684617042542, 0.035770706832408905, -0.4306381642818451, -0.03530200570821762, 0.048710305243730545, 0.0],
        [0.03204982355237007, 0.0875689759850502, -0.14198140799999237, -0.17556169629096985, 0.028996653854846954, 0.056999240070581436, 0.0],
        [-4.6566128730773926e-09, -0.030018121004104614, -0.004341546446084976, -0.0573662668466568, -0.002178945578634739, -0.030649537220597267, 0.0],
        [-3.818422555923462e-08, -0.09983345866203308, 0.1976768672466278, 0.38355714082717896, -0.16922688484191895, -0.7718640565872192, 0.2063736468553543],
        [-2.9802322387695312e-08, 0.9950042963027954, 0.01983383297920227, -0.921649158000946, -0.13263818621635437, 0.6340002417564392, 0.3207150399684906],
        [1.0, -2.9802322387695312e-08, 0.9800665974617004, -0.05871081352233887, 0.9766112565994263, -0.04764178395271301, 0.9244197010993958]
    ], device=device)
    # fmt: on
    assert torch.allclose(J, J_expected, atol=1e-5)

    # test shadow_hand_right with ee_link_names "thtip"
    arti = Articulation(
        ArticulationSpec(urdf_or_mjcf_path="assets/robot_description/shadow_hand_right.urdf", ee_link_names="thtip"),
        device=device,
    )
    J = arti.jacobian(joint_values, clamp_joint_values=False, **maybe_kwargs)
    # fmt: off
    J_expected = torch.tensor([
        [8.009374141693115e-07, 0.09826014935970306, -0.04998847097158432, 0.048952799290418625, 0.016808131709694862, -0.043275464326143265, -0.02375316433608532],
        [0.12811866402626038, -0.005535600706934929, -0.015557218343019485, -0.043433111160993576, -0.024772828444838524, -0.034467913210392, -0.012858779169619083],
        [-0.047895681113004684, -0.05516534298658371, 0.03076891228556633, -0.023527145385742188, -0.015620534308254719, 0.008097551763057709, -0.005166143644601107],
        [-1.0, 6.198883056640625e-06, -0.1404852271080017, 0.15542711317539215, 0.15542711317539215, 0.4977685809135437, 0.4977685809135437],
        [6.258487701416016e-06, 0.9950041174888611, -0.7727590203285217, 0.600192129611969, 0.600192129611969, -0.7336410880088806, -0.7336410880088806],
        [7.450580596923828e-08, -0.0998334288597107, -0.6189565658569336, -0.7846093773841858, -0.7846093773841858, -0.46259820461273193, -0.46259820461273193]
    ], device=device)
    # fmt: on
    assert torch.allclose(J, J_expected, atol=1e-5)

    # test shadow_hand_right with target_links using zero joint values
    arti = Articulation(
        ArticulationSpec(urdf_or_mjcf_path="assets/robot_description/shadow_hand_right.urdf"),
        device=device,
    )
    zero_joints = torch.zeros(arti.total_num_dofs, device=device)
    # fmt: off
    J_expected = torch.tensor([
        [8.257629815489054e-07, 0.09794289618730545, 0.0, 0.09749998897314072, 0.05949999764561653, -2.633124154272082e-07, -1.2169901708602993e-07],
        [0.13194289803504944, -6.132759153842926e-07, 0.0, -6.102025054133264e-07, -3.723800148236478e-07, -0.042072851210832596, -0.01944543421268463],
        [-0.10294290632009506, -0.008580000139772892, 0.0, 0.0, 0.0, 0.04207285866141319, 0.01944543793797493],
        [-0.9999999403953552, 6.258487701416016e-06, -4.425419319886714e-06, 4.425418865139363e-06, 4.425418865139363e-06, 0.9999999403953552, 0.9999999403953552],
        [6.258487701416016e-06, 0.9999999403953552, -0.7071067690849304, 0.7071067094802856, 0.7071067094802856, -6.258487701416016e-06, -6.258487701416016e-06],
        [0.0, -1.7114274442064925e-08, -0.7071067094802856, -0.7071068286895752, -0.7071068286895752, 0.0, 0.0],
    ], device=device)
    # fmt: on
    J = arti.jacobian(zero_joints, clamp_joint_values=False, target_links="thtip", **maybe_kwargs)
    cols = [0, 1, 19, 20, 21, 22, 23]
    assert torch.allclose(J[..., [0, 1, 19, 20, 21, 22, 23]], J_expected, atol=1e-5)
    mask = torch.tensor([i not in cols for i in range(J.shape[-1])], device=device)
    assert torch.allclose(J[..., mask], torch.zeros_like(J[..., mask]), atol=1e-5)

    # test multi-articulation: kuka_iiwa and shadow_hand_right
    multi_joint_values = torch.tensor(
        [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7], device=device
    )
    arti = Articulation(
        [
            ArticulationSpec(urdf_or_mjcf_path="assets/robot_description/kuka_iiwa.urdf"),
            ArticulationSpec(
                urdf_or_mjcf_path="assets/robot_description/shadow_hand_right.urdf", ee_link_names="thtip"
            ),
        ],
        device=device,
    )
    J = arti.jacobian(multi_joint_values, clamp_joint_values=False, **maybe_kwargs)
    # fmt: off
    J_expected = torch.tensor([
        [0.01874709501862526, 0.8727684617042542, 0.035770706832408905, -0.4306381642818451, -0.03530200570821762, 0.048710305243730545, 0.0],
        [0.03204982355237007, 0.0875689759850502, -0.14198140799999237, -0.17556169629096985, 0.028996653854846954, 0.056999240070581436, 0.0],
        [-4.6566128730773926e-09, -0.030018121004104614, -0.004341546446084976, -0.0573662668466568, -0.002178945578634739, -0.030649537220597267, 0.0],
        [-3.818422555923462e-08, -0.09983345866203308, 0.1976768672466278, 0.38355714082717896, -0.16922688484191895, -0.7718640565872192, 0.2063736468553543],
        [-2.9802322387695312e-08, 0.9950042963027954, 0.01983383297920227, -0.921649158000946, -0.13263818621635437, 0.6340002417564392, 0.3207150399684906],
        [1.0, -2.9802322387695312e-08, 0.9800665974617004, -0.05871081352233887, 0.9766112565994263, -0.04764178395271301, 0.9244197010993958]
    ], device=device)
    # fmt: on
    assert torch.allclose(J[..., :7], J_expected, atol=1e-5)
    # fmt: off
    J_expected = torch.tensor([
        [8.009374141693115e-07, 0.09826014935970306, -0.04998847097158432, 0.048952799290418625, 0.016808131709694862, -0.043275464326143265, -0.02375316433608532],
        [0.12811866402626038, -0.005535600706934929, -0.015557218343019485, -0.043433111160993576, -0.024772828444838524, -0.034467913210392, -0.012858779169619083],
        [-0.047895681113004684, -0.05516534298658371, 0.03076891228556633, -0.023527145385742188, -0.015620534308254719, 0.008097551763057709, -0.005166143644601107],
        [-1.0, 6.198883056640625e-06, -0.1404852271080017, 0.15542711317539215, 0.15542711317539215, 0.4977685809135437, 0.4977685809135437],
        [6.258487701416016e-06, 0.9950041174888611, -0.7727590203285217, 0.600192129611969, 0.600192129611969, -0.7336410880088806, -0.7336410880088806],
        [7.450580596923828e-08, -0.0998334288597107, -0.6189565658569336, -0.7846093773841858, -0.7846093773841858, -0.46259820461273193, -0.46259820461273193]
    ], device=device)
    # fmt: on
    assert torch.allclose(J[..., 7:], J_expected, atol=1e-5)

    # test multi-articulation: shadow_hand_right and panda with target_links
    arti = Articulation(
        [
            ArticulationSpec(urdf_or_mjcf_path="assets/robot_description/shadow_hand_right.urdf"),
            ArticulationSpec(urdf_or_mjcf_path="assets/robot_description/panda.urdf"),
        ],
        device=device,
    )
    joint_values = torch.zeros(arti.total_num_dofs, device=device)
    J, eef_pose = arti.jacobian(
        joint_values,
        clamp_joint_values=False,
        target_links=["rfdistal", "panda_rightfinger"],
        return_target_link_poses=True,
        **maybe_kwargs,
    )
    # fmt: off
    J_expected = torch.tensor([
        [1.2454390798666282e-06, 0.16499997675418854, 4.380941334147792e-07, 0.06999999284744263, 0.02499999850988388, 0.0],
        [0.19899998605251312, -1.03265040252154e-06, 0.06999999284744263, -4.380941334147792e-07, -1.564621925354004e-07, 0.0],
        [0.010999999940395355, 0.0, 0.0, 0.0, 0.0, 0.0],
        [-0.9999999403953552, 6.258487701416016e-06, -0.9999999403953552, 6.258487701416016e-06, 6.258487701416016e-06, 6.258487701416016e-06],
        [6.258487701416016e-06, 0.9999999403953552, 6.258487701416016e-06, 0.9999999403953552, 0.9999999403953552, 0.9999999403953552],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    ], device=device)
    eef_pose_expected = torch.tensor(
        [[[6.258487701416016e-06, -0.9999999403953552, 0.0, 0.009999929927289486],
        [0.9999999403953552, 6.258487701416016e-06, 0.0, -0.01100006140768528],
        [0.0, 0.0, 1.0, 0.41200998425483704],
        [0.0, 0.0, 0.0, 1.0]]], device=device)
    # fmt: on
    assert torch.allclose(J[..., [0, 1, 10, 11, 12, 13]], J_expected, atol=1e-6)
    assert torch.allclose(J[..., [2, 3, 4, 5, 6, 7]], torch.zeros_like(J[..., [2, 3, 4, 5, 6, 7]]), atol=1e-6)
    assert torch.allclose(eef_pose[0], eef_pose_expected, atol=1e-6)
    # fmt: off
    J_expected = torch.tensor([
        [1.4151515514981838e-09, 0.534600019454956, 1.4151515514981838e-09, -0.21860000491142273, 1.4151515514981838e-09, 0.16539999842643738, 0.0, -0.7071068286895752],
        [0.08799999952316284, 3.1307081371778622e-09, 0.08799999952316284, 6.210157721397991e-09, 0.08799999952316284, 4.092256311594156e-09, 0.0, 0.7071067094802856],
        [0.0, -0.08799999952316284, 0.0, 0.005499996244907379, 0.0, 0.08799999952316284, 0.0, 0.0],
        [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
        [0.0, 1.0, 0.0, -1.0, 0.0, -1.0, 0.0, 0.0],
        [1.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0],
    ], device=device)
    eef_pose_expected = torch.tensor(
        [[[0.7071067094802856, 0.7071068286895752, 0.0, 0.08799999952316284],
        [0.7071068286895752, -0.7071067094802856, 0.0, 0.0],
        [0.0, 0.0, -1.0, 0.8676000237464905],
        [0.0, 0.0, 0.0, 1.0]]], device=device)
    # fmt: on
    assert torch.allclose(J[..., [24, 25, 26, 27, 28, 29, 30, 32]], J_expected, atol=1e-6)
    assert torch.allclose(eef_pose[1], eef_pose_expected, atol=1e-6)


def test_basic() -> None:
    _run_jacobian_tests()


def test_pytorch_jacobian() -> None:
    _run_jacobian_tests(use_warp=False)
