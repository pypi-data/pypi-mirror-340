import numpy as np
from abc import (
    ABC,
    abstractmethod,
)  # Import ABC and abstractmethod for creating abstract classes


class Indicator(ABC):
    def __init__(
        self,
        window: int,  # Length of history window for the indicator computation
        nColumns: int,  # Number of output columns generated by the indicator
        color: list[str],  # Visualization color(s) for the indicator
        line_dash: list[str],  # Line style(s) for the indicator (e.g., solid, dashed)
        line_width: list[float],  # Line width(s) for the indicator
        visible: bool = False,  # Flag to indicate whether the indicator is visible in the chart
        mode: str = "chart",  # Visualization mode (chart, log, etc.)
        # Price data column the indicator is applied to (e.g., "Close", "Open")
        applyTo: str = "Close",
    ):
        """
        Initialize the Indicator object with parameters necessary for calculation and visualization.

        Args:
            window (int): The history window (e.g., number of periods) to be considered for computation.
            nColumns (int): The number of output columns generated by this indicator (e.g., 1 for simple indicators).
            color (list[str]): A list of colors used for visualization (can be multiple for multi-line indicators).
            line_dash (list[str]): Line style(s) used for the indicator (e.g., "solid", "dashed").
            line_width (list[float]): Line width(s) used for the indicator.
            visible (bool): A flag indicating if the indicator should be visible in charts.
            mode (str): The mode for displaying the indicator (e.g., "chart" for standard chart data).
            applyTo (str): The price data column to which the indicator will be applied (e.g., "Close", "Open").
        """
        self.window = window
        self.nColumns = nColumns
        self.color = color
        self.line_dash = line_dash
        self.line_width = line_width
        self.visible = visible
        self.mode = mode
        self.applyTo = applyTo

        # This will hold the range of columns where the indicator's data will be stored in the database
        self.idx_range = None

    @abstractmethod
    def compute(self, data, dt=None):
        """
        Compute the values of the indicator. This method should be overridden by each specific indicator.

        Args:
            data (np.ndarray): The market data (OHLCV data or indicators).
            dt (optional, np.ndarray): Timestamps corresponding to the data, if required for the indicator.

        Returns:
            np.ndarray: The computed indicator values.
        """
        pass

    @abstractmethod
    def column_name(self):
        """
        Return the names of the columns that will be generated for this indicator.
        Should be overridden by each specific indicator class.

        Returns:
            list[str]: A list of column names for this indicator.
        """
        pass


class SMA(Indicator):
    """
    Simple Moving Average (SMA) Indicator.
    Computes the moving average of a specified column over a given window.
    """

    def __init__(
        self,
        window: int = 14,  # Length of the moving average window
        color="red",  # Line color for visualization
        line_dash="solid",  # Line style for visualization
        line_width=1,  # Line width for visualization
        visible=False,  # Visibility of the indicator
        applyTo="Close",  # The price to apply the moving average to (e.g., "Close")
    ):
        """
        Initializes the SMA indicator with the provided parameters.

        Args:
            window (int): The period of the moving average.
            color (str): Line color for visualization.
            line_dash (str): Line dash style for visualization.
            line_width (int): Width of the line for visualization.
            visible (bool): Flag for whether the indicator is visible.
            applyTo (str): Column name (e.g., "Close") to apply the indicator to.
        """
        # Call the parent class constructor
        super().__init__(
            window=window,
            nColumns=1,  # SMA is a single column indicator
            color=[color],
            line_dash=[line_dash],
            line_width=[line_width],
            visible=visible,
            mode="chart",  # Visualization mode
            applyTo=applyTo,
        )

        # Store the index of the column (e.g., 'Close')
        self.applyTo_idx = applyTo_idx(self.applyTo)

    def compute(self, dt, data):
        """
        Computes the Simple Moving Average for the given data.

        Args:
            dt: The datetime values (not used for SMA computation, but might be used in other indicators).
            data: The OHLCV data array.

        Returns:
            float: The computed SMA value or NaN if there is insufficient data.
        """
        # If there's not enough data to compute the SMA, return NaN
        if data.shape[0] < self.window:
            return np.nan  # Return NaN instead of 'np.float32("nan")' for simplicity

        # Calculate and return the mean of the 'applyTo' column for the last `window` rows
        return np.mean(data[-self.window :, self.applyTo_idx])

    def column_name(self):
        """
        Returns the name of the column for this indicator.

        Returns:
            list: A list containing the column name, which is 'sma_{window}'.
        """
        return [f"sma_{self.window}"]


class EMA(Indicator):
    """
    Exponential Moving Average (EMA) Indicator.
    Computes the exponentially weighted moving average of a specified column over a given window.
    """

    def __init__(
        self,
        window: int = 14,  # Length of the moving average window
        color="red",  # Line color for visualization
        line_dash="solid",  # Line style for visualization
        line_width=1,  # Line width for visualization
        visible=False,  # Visibility of the indicator
        applyTo="Close",  # The price to apply the moving average to (e.g., "Close")
    ):
        """
        Initializes the EMA indicator with the provided parameters.

        Args:
            window (int): The period of the moving average.
            color (str): Line color for visualization.
            line_dash (str): Line dash style for visualization.
            line_width (int): Width of the line for visualization.
            visible (bool): Flag for whether the indicator is visible.
            applyTo (str): Column name (e.g., "Close") to apply the indicator to.
        """
        # Call the parent class constructor to initialize basic attributes
        super().__init__(
            window=window,
            nColumns=1,  # EMA is a single column indicator
            color=[color],
            line_dash=[line_dash],
            line_width=[line_width],
            visible=visible,
            mode="chart",  # Visualization mode
            applyTo=applyTo,
        )

        # Store the index of the column (e.g., 'Close')
        self.applyTo_idx = applyTo_idx(self.applyTo)

        # Compute the weights for the EMA (more recent values have higher weight)
        self.weights = (1 - (2 / (self.window + 1))) ** np.arange(
            window, 0, -1, dtype=np.float32
        )
        self.sum_weights = np.sum(
            self.weights
        )  # The sum of the weights (used for normalization)

    def compute(self, dt, data):
        """
        Computes the Exponential Moving Average for the given data.

        Args:
            dt: The datetime values (not used for EMA computation, but might be used in other indicators).
            data: The OHLCV data array.

        Returns:
            float: The computed EMA value or NaN if there is insufficient data.
        """
        # If there's not enough data to compute the EMA, return NaN
        if data.shape[0] < self.window:
            return np.nan  # Return NaN for insufficient data

        # Calculate and return the exponentially weighted moving average
        return (
            np.sum(data[-self.window :, self.applyTo_idx] * self.weights)
            / self.sum_weights
        )

    def column_name(self):
        """
        Returns the name of the column for this indicator.

        Returns:
            list: A list containing the column name, which is 'ema_{window}'.
        """
        return [f"ema_{self.window}"]


class BB(Indicator):
    """
    Bollinger Bands Indicator.
    Computes the upper, middle, and lower Bollinger Bands for a given price series (e.g., "Close").
    The bands are calculated based on a simple moving average and standard deviation.
    """

    def __init__(
        self,
        window: int = 14,  # Length of the moving average window
        color=[
            "red",
            "red",
            "red",
        ],  # Line colors for the three bands (upper, middle, lower)
        line_dash=["solid", "dashed", "solid"],  # Line styles for visualization
        line_width=[1, 1, 1],  # Line widths for the bands
        visible=False,  # Visibility flag for the indicator
        applyTo="Close",  # Price series to apply the indicator to (e.g., "Close")
        dev=2.0,  # Number of standard deviations for the bands
    ):
        """
        Initializes the Bollinger Bands (BB) indicator.

        Args:
            window (int): The period for calculating the moving average and standard deviation.
            color (list of str): Line colors for the upper, middle, and lower bands.
            line_dash (list of str): Line styles for the three bands.
            line_width (list of float): Line widths for the bands.
            visible (bool): If True, the indicator is visible.
            applyTo (str): The price series to calculate the bands (e.g., "Close").
            dev (float): The multiplier for the standard deviation (commonly 2).
        """
        # Initialize the parent Indicator class with specific parameters
        super().__init__(
            window=window,
            nColumns=3,  # Bollinger Bands have three columns: upper, middle, and lower bands
            color=color,
            line_dash=line_dash,
            line_width=line_width,
            visible=visible,
            mode="chart",
            applyTo=applyTo,
        )
        self.dev = dev  # Standard deviation multiplier

        # Store the index of the selected price series (e.g., "Close")
        self.applyTo_idx = applyTo_idx(self.applyTo)

    def compute(self, dt, data):
        """
        Computes the Bollinger Bands for the given data.

        Args:
            dt: The datetime values (not used in BB computation but might be used in other indicators).
            data: The OHLCV data array.

        Returns:
            np.ndarray: An array with the upper, middle, and lower Bollinger Bands.
        """
        # If there's not enough data to compute the bands, return NaN values for all bands
        if data.shape[0] < self.window:
            return np.full(shape=(3,), fill_value=np.nan, dtype=np.float32)

        # Calculate the standard deviation and mean of the selected price series over the window
        sigma = np.std(data[-self.window :, self.applyTo_idx])  # Standard deviation
        mu = np.mean(
            data[-self.window :, self.applyTo_idx]
        )  # Mean (simple moving average)

        # Calculate the upper, middle, and lower Bollinger Bands
        upper_band = mu + self.dev * sigma
        middle_band = mu
        lower_band = mu - self.dev * sigma

        # Return the calculated bands as an array
        return np.array([upper_band, middle_band, lower_band])

    def column_name(self):
        """
        Returns the column names for the three Bollinger Bands.

        Returns:
            list: A list containing the column names for the upper, middle, and lower bands.
        """
        return [
            "bb_" + str(self.window) + "_dev_" + str(self.dev) + "_" + band_name
            for band_name in ["upper", "middle", "lower"]
        ]


class RSI(Indicator):
    """
    Relative Strength Index (RSI) Indicator.
    Computes the RSI, which measures the speed and change of price movements.
    RSI values range from 0 to 100, indicating overbought conditions (above 70) and oversold conditions (below 30).

    Formula:
        RSI = 100 - (100 / (1 + RS))
        Where RS = Average Gain / Average Loss
    """

    def __init__(
        self,
        window: int = 14,  # Length of the window for calculating RSI (usually 14)
        color="red",  # Line color for the RSI plot
        line_dash="solid",  # Line style for visualization
        line_width=1,  # Line width for visualization
        visible=False,  # Indicator visibility
        applyTo="Close",  # Price series to apply RSI (usually "Close")
    ):
        """
        Initializes the RSI indicator.

        Args:
            window (int): The number of periods to use for the RSI calculation.
            color (str): The color for the RSI plot line.
            line_dash (str): The line style for the plot.
            line_width (float): The width of the RSI plot line.
            visible (bool): Whether the RSI line is visible.
            applyTo (str): The price series to use for calculation (e.g., "Close").
        """
        # Initialize the parent class with relevant parameters
        super().__init__(
            window=window,
            nColumns=1,  # RSI is a single column indicator
            color=[color],
            line_dash=[line_dash],
            line_width=[line_width],
            visible=visible,
            mode="0-100",  # RSI operates within the 0-100 range
            applyTo=applyTo,
        )

        # Store the index of the selected price column (e.g., "Close")
        self.applyTo_idx = applyTo_idx(self.applyTo)

    def compute(self, dt, data):
        """
        Computes the RSI for the given data.

        Args:
            dt: The datetime values (not used in RSI computation but required for consistency).
            data: The OHLCV data array (numpy array).

        Returns:
            float: The computed RSI value.
        """
        # If there's not enough data (less than the window size + 1), return NaN
        if data.shape[0] < (self.window + 1):
            return np.float32("nan")

        # Calculate price changes (delta) over the specified window
        delta = np.diff(data[-(self.window + 1) :, self.applyTo_idx])  # Price changes

        # Separate the positive and negative changes
        gains = np.where(delta > 0, delta, 0)  # Gains (positive changes)
        losses = np.where(delta < 0, -delta, 0)  # Losses (negative changes)

        # Calculate the average gain and average loss over the window
        avg_gain = np.mean(gains)
        avg_loss = np.mean(losses)

        # To avoid division by zero, we use a small constant (1e-12) for the average loss
        rs = avg_gain / max(avg_loss, 1e-12)  # Relative Strength

        # Calculate RSI using the formula
        rsi_value = 100 - (100 / (1 + rs))

        return rsi_value

    def column_name(self):
        """
        Returns the column name for the RSI indicator.

        Returns:
            list: A list with the RSI column name, including the window size.
        """
        return ["rsi_" + str(self.window)]


class SO(Indicator):
    """
    Stochastic Oscillator (SO) Indicator.
    The Stochastic Oscillator is used to measure the momentum of price movements by comparing the current price to the
    price range over a specific period.

    Formula:
        %K = 100 * (Current Close - Lowest Low) / (Highest High - Lowest Low)
        %D = Moving Average of %K (usually over 3-4 periods)

    %K is often referred to as the raw Stochastic value, while %D is a smoother version (often a moving average of %K).
    """

    def __init__(
        self,
        window: int = 14,  # Look-back window for calculating the stochastic oscillator
        color=["blue", "red"],  # Colors for the %K and %D lines
        line_dash=["solid", "dashed"],  # Line styles for visualization
        line_width=[1, 1],  # Line widths for visualization
        visible=False,  # Indicator visibility
        # Price series to apply the oscillator to (e.g., "Close")
        applyTo="Close",
        av_window=4,  # Window size for smoothing %K to calculate %D
    ):
        """
        Initializes the Stochastic Oscillator (SO) indicator.

        Args:
            window (int): The number of periods over which to calculate the Stochastic Oscillator.
            color (list): List of colors for visualizing %K and %D.
            line_dash (list): List of line styles for %K and %D.
            line_width (list): List of line widths for %K and %D.
            visible (bool): Whether the indicator lines should be visible.
            applyTo (str): The price series to use for the oscillator calculation (usually "Close").
            av_window (int): The window size for smoothing %K to calculate %D (typically 3-4).
        """
        # Initialize the parent Indicator class with the appropriate parameters
        super().__init__(
            window=window,
            # Stochastic Oscillator generates two columns (%K and %D)
            nColumns=2,
            color=color,
            line_dash=line_dash,
            line_width=line_width,
            visible=visible,
            mode="0-100",  # The Stochastic Oscillator values range from 0 to 100
            applyTo=applyTo,
        )

        # Store additional attributes
        self.av_window = av_window  # Smoothing window for %D

        # Store indices for the selected price columns (e.g., Close, High, Low)
        self.applyTo_idx = applyTo_idx(self.applyTo)
        self.high_idx = applyTo_idx("High")
        self.low_idx = applyTo_idx("Low")

    def compute(self, dt, data):
        """
        Computes the Stochastic Oscillator (%K and %D) for the given data.

        Args:
            dt: The datetime values (not used in calculation, required for consistency).
            data: The OHLCV data array (numpy array).

        Returns:
            np.array: An array containing the %K value and the smoothed %D value.
        """
        # If not enough data for the window, return NaN values
        if data.shape[0] < self.window:
            return np.full(2, np.nan, dtype=np.float32)

        # Calculate the highest high and lowest low over the look-back window
        hh = np.max(data[-self.window :, self.high_idx])  # Highest high in the window
        ll = np.min(data[-self.window :, self.low_idx])  # Lowest low in the window

        # Calculate the %K value: the relative position of the current close within the window range
        os = 100 * (data[-1, self.applyTo_idx] - ll) / max(hh - ll, 1e-12)

        # Calculate the %D value: the moving average of %K over the specified smoothing window
        # Mean of the last 'av_window' %K values
        os_mean = np.mean(data[-self.av_window :, self.applyTo_idx])

        # Return both %K and smoothed %D values
        return np.array([os, os_mean])

    def column_name(self):
        """
        Returns the column names for the Stochastic Oscillator (%K and %D).

        Returns:
            list: A list containing column names for %K and %D.
        """
        return ["so_" + str(self.window) + signal_name for signal_name in ["", "_mean"]]


class VR(Indicator):
    """
    Volume Rate of Change (VR) Indicator.
    This indicator measures the ratio of the current volume to the average volume
    over a specified window. It is used to identify changes in volume that can
    signal shifts in market sentiment.

    Formula:
        VR = Current Volume / Average Volume over the window

    Arguments:
        window (int): The number of periods to calculate the average volume.
        color (str): Color for visualizing the indicator.
        line_dash (str): Line style for visualizing the indicator.
        line_width (float): Line width for visualizing the indicator.
        visible (bool): Whether to display the indicator.
        applyTo (str): The price series to apply the indicator to (default is "Volume").
    """

    def __init__(
        self,
        window: int = 14,  # Length of the window for averaging volume
        color="red",  # Color for the visualization line
        line_dash="solid",  # Line style for the visualization
        line_width=1,  # Line width for the visualization
        visible=False,  # Indicator visibility
        applyTo="Volume",  # Column to apply the indicator (usually "Volume")
    ):
        """
        Initializes the VR (Volume Rate of Change) indicator with the specified parameters.

        Args:
            window (int): The number of periods over which the volume rate is calculated.
            color (str): Color for the indicator line.
            line_dash (str): Style for the indicator line.
            line_width (float): Width of the indicator line.
            visible (bool): Whether the indicator should be visible in the chart.
            applyTo (str): Which price column to apply the indicator to (usually "Volume").
        """
        # Call the parent Indicator class to initialize its attributes
        super().__init__(
            window=window,
            nColumns=1,  # Only one output column for VR
            color=[color],  # List of colors for the indicator
            line_dash=[line_dash],  # List of line styles for the indicator
            line_width=[line_width],  # List of line widths for the indicator
            visible=visible,  # Whether the indicator is visible
            # Mode of the indicator (typically positive for VR)
            mode="positive",
            applyTo=applyTo,  # Apply indicator to volume
        )

        # Store the index of the selected price/volume column
        self.applyTo_idx = applyTo_idx(self.applyTo)

    def compute(self, dt, data):
        """
        Computes the Volume Rate of Change (VR) for the given data.

        Args:
            dt: The datetime values (not used in calculation, but needed for consistency).
            data: The OHLCV data array (numpy array).

        Returns:
            float: The VR value (ratio of current volume to the average volume over the window).
        """
        # If not enough data for the window, return NaN
        if data.shape[0] < self.window:
            return np.float32("nan")

        # Calculate the Volume Rate as current volume divided by the average volume over the window
        current_volume = data[-1, self.applyTo_idx]
        average_volume = np.mean(data[-self.window :, self.applyTo_idx])

        # Return the volume rate of change (VR) with a small epsilon to prevent division by zero
        return current_volume / (average_volume + 1e-6)

    def column_name(self):
        """
        Returns the column name for the Volume Rate of Change (VR) indicator.

        Returns:
            list: A list containing the name of the output column.
        """
        return ["vr_" + str(self.window)]


class STD(Indicator):
    """
    Standard Deviation (STD) Indicator.
    This indicator calculates the standard deviation of the chosen price (e.g., Close)
    over a specified window. Standard deviation is often used to measure the volatility
    or risk of a security.

    Formula:
        STD = sqrt( (sum( (x_i - mean)^2 )) / N )

    Arguments:
        window (int): The number of periods over which the standard deviation is calculated.
        color (str): The color for visualizing the standard deviation line.
        line_dash (str): The line style for visualizing the standard deviation line.
        line_width (float): The line width for the standard deviation visualization.
        visible (bool): Whether the indicator is visible on the chart.
        applyTo (str): The price column (e.g., "Close", "High") to which the standard deviation is applied.
    """

    def __init__(
        self,
        window: int = 14,  # Length of the window over which standard deviation is calculated
        color="red",  # Color for the standard deviation line
        line_dash="solid",  # Line style for the standard deviation line
        line_width=1,  # Line width for the standard deviation line
        visible=False,  # Whether the indicator should be visible
        applyTo="Close",  # The column to apply the indicator to (default "Close")
    ):
        """
        Initializes the Standard Deviation (STD) indicator with the given parameters.

        Args:
            window (int): The number of periods over which to calculate standard deviation.
            color (str): Color for the indicator line.
            line_dash (str): Style for the indicator line.
            line_width (float): Width of the indicator line.
            visible (bool): Whether the indicator is visible on the chart.
            applyTo (str): The price column to apply the indicator to.
        """
        # Initialize the parent Indicator class
        super().__init__(
            window=window,
            nColumns=1,  # Only one output column for standard deviation
            color=[color],  # List of colors for the indicator
            line_dash=[line_dash],  # List of line styles for the indicator
            line_width=[line_width],  # List of line widths for the indicator
            visible=visible,  # Indicator visibility
            # Mode for positive values (std is always positive)
            mode="positive",
            # Apply to the specified price column (e.g., Close)
            applyTo=applyTo,
        )

        # Store the index of the selected price column
        self.applyTo_idx = applyTo_idx(self.applyTo)

    def compute(self, dt, data):
        """
        Computes the standard deviation (STD) for the given data.

        Args:
            dt: The datetime values (not used in this calculation but required for consistency).
            data: The OHLCV data array (numpy array).

        Returns:
            float: The standard deviation of the chosen price series over the window.
        """
        # If there isn't enough data for the specified window, return NaN
        if data.shape[0] < self.window:
            return np.float32("nan")

        # Calculate the standard deviation over the specified window
        return np.std(data[-self.window :, self.applyTo_idx])

    def column_name(self):
        """
        Returns the column name for the standard deviation indicator.

        Returns:
            list: A list containing the name of the output column.
        """
        return ["std_" + str(self.window)]


class TOD(Indicator):
    """
    Time of Day (TOD) Indicator.
    This indicator calculates the normalized time of day, which is a value between 0 and 1.
    It is based on the current hour and minute of the given timestamp.

    Formula:
        TOD = (60 * hour + minute) / 1440

    Where:
        - `hour`: The hour of the timestamp (0 to 23)
        - `minute`: The minute of the timestamp (0 to 59)
        - 1440 is the total number of minutes in a day (24 hours * 60 minutes)

    Arguments:
        color (str): The color for visualizing the indicator line.
        line_dash (str): The line style for the indicator line.
        line_width (float): The width of the indicator line.
        visible (bool): Whether the indicator is visible on the chart.
    """

    def __init__(self, color="red", line_dash="solid", line_width=1, visible=False):
        """
        Initializes the Time of Day (TOD) indicator with the given parameters.

        Args:
            color (str): Color for the indicator line.
            line_dash (str): Style for the indicator line.
            line_width (float): Width of the indicator line.
            visible (bool): Whether the indicator is visible on the chart.
        """
        # Initialize the parent Indicator class with default window size of 1 (only 1 value per timestamp)
        super().__init__(
            window=1,
            nColumns=1,  # Only one column for the Time of Day value
            color=[color],  # Color for the indicator line
            line_dash=[line_dash],  # Line style for the indicator
            line_width=[line_width],  # Line width for the indicator
            visible=visible,  # Indicator visibility
            mode="0-1",  # Mode indicating a normalized value between 0 and 1
        )

    def compute(self, dt, data):
        """
        Computes the Time of Day (TOD) value based on the provided timestamp.

        Args:
            dt (list): A list of datetime objects (with `hour` and `minute` attributes).
            data: The OHLCV data (not used in this case).

        Returns:
            float: A value between 0 and 1 representing the time of day.
        """
        # Calculate the total minutes from the start of the day and normalize by 1440 minutes (24 hours * 60 minutes)
        return (60 * dt[-1].hour + dt[-1].minute) / 1440.0

    def column_name(self):
        """
        Returns the name of the output column for the Time of Day (TOD) indicator.

        Returns:
            list: A list containing the name of the output column.
        """
        return ["time_of_day"]


def applyTo_idx(applyTo: str):
    """
    Returns the index of the column corresponding to the given 'applyTo' value.

    Args:
        applyTo (str): The name of the data column ("Open", "High", "Low", "Close", "Volume").

    Returns:
        int: The index of the column in the data array.

    Raises:
        ValueError: If the applyTo argument is not a valid OHLCV column name.
    """
    # Dictionary to map column names to indices
    column_map = {"Open": 0, "High": 1, "Low": 2, "Close": 3, "Volume": 4}

    # Normalize applyTo to handle case-insensitive input
    applyTo = applyTo.strip().capitalize()

    # Check if the applyTo value is valid
    if applyTo not in column_map:
        raise ValueError(
            f"Invalid column name: '{applyTo}'. Must be one of {list(column_map.keys())}."
        )

    # Return the corresponding index
    return column_map[applyTo]


def collection():
    """
    This function returns a default collection of important technical indicators.
    The set includes Bollinger Bands (BB), Exponential Moving Averages (EMA),
    Relative Strength Index (RSI), Stochastic Oscillator (SO), Time of Day (TOD),
    and Standard Deviation (STD) indicators with different parameter configurations.

    Returns:
        list: A list of indicator objects ready for use in data analysis or trading strategies.
    """

    # Bollinger Bands with varying window lengths and standard deviations
    bb_indicators = [
        BB(10, dev=1.5),  # 10-period, 1.5 standard deviation
        BB(20, dev=2.0),  # 20-period, 2.0 standard deviation
        BB(50, dev=2.0),  # 50-period, 2.0 standard deviation
        BB(100, dev=2.0),  # 100-period, 2.0 standard deviation
        BB(200, dev=2.0),  # 200-period, 2.0 standard deviation
    ]

    # Exponential Moving Averages with different windows
    ema_indicators = [
        EMA(10),  # 10-period EMA
        EMA(20),  # 20-period EMA
        EMA(50),  # 50-period EMA
        EMA(100),  # 100-period EMA
        EMA(200),  # 200-period EMA
    ]

    # Relative Strength Index (RSI) with different window lengths
    rsi_indicators = [
        RSI(5),  # 5-period RSI
        RSI(9),  # 9-period RSI
        RSI(14),  # 14-period RSI (commonly used)
        RSI(21),  # 21-period RSI
        RSI(30),  # 30-period RSI
    ]

    # Stochastic Oscillator (SO) with different windows and averaging periods
    so_indicators = [
        SO(5, av_window=2),  # 5-period SO, 2-period average
        SO(9, av_window=3),  # 9-period SO, 3-period average
        SO(14, av_window=4),  # 14-period SO, 4-period average
        SO(21, av_window=5),  # 21-period SO, 5-period average
        SO(30, av_window=6),  # 30-period SO, 6-period average
    ]

    # Time of Day (TOD) indicator, normalized between 0 and 1
    tod_indicator = [TOD()]

    # Standard Deviation (STD) with different window lengths
    std_indicators = [
        STD(5),  # 5-period STD
        STD(10),  # 10-period STD
        STD(15),  # 15-period STD
        STD(20),  # 20-period STD
        STD(30),  # 30-period STD
        STD(50),  # 50-period STD
    ]

    # Combine all the indicators into a single list and return
    return (
        bb_indicators
        + ema_indicators
        + rsi_indicators
        + so_indicators
        + tod_indicator
        + std_indicators
    )
