"""
    This file contains the implementation of the GUHA method 4FT-Miner for generating and evaluating association rules on the given dataset.
"""

import pandas as pd
import numpy as np

from typing import List, Sequence, Union
from datetime import datetime
from timeit import default_timer as timer

from .cedents import Cedent
from .generation import generate_cedent

from ..computation import get_query_card
from ..logic import Rule
from ..quantifiers import Quantifier, Base, Statistical, Founded


class FourFtMiner():
    """Implementation of 4FtMiner method for generating and evaluating association rules on the given dataset.
    The method is based on the GUHA (General Unary Hypotheses Automaton) method. This metod is implemented mainly based on the paper:
        An alternative approach to mining association rules **[4]**.
        Mechanizing hypothesis formation: Principles and Case Studies **[6]**.

    Args:
        data (pd.DataFrame): The dataset that will be used to generate rules.
        rel_antecedent (Cedent): Collection of definitions of how to generate antecedent.
        rel_succedent (Cedent): Collection of definitions of how to generate succedent.
        quantifiers (Sequence[Quantifier]): A list of quantifiers that will be used to evaluate quality of rules.
        relevant_cond (Cedent, optional): **Not yet implemented.** Collection of definitions of how to generate conditions. Defaults to None.

    For more information about the parameters, see the class attributes in the class documentation.
    """

    data: pd.DataFrame
    "The dataset that will be used to generate rules."
    rel_antecedent: Cedent
    "Collection of definitions of how to generate antecedent."
    rel_succedent: Cedent
    "Collection of definitions of how to generate succedent."
    quantifiers: Sequence[Quantifier]
    "A list of quantifiers that will be used to evaluate quality of rules."
    relevant_cond: Union[Cedent, None]
    "**Not yet implemented.** Collection of definitions of how to generate conditions."

    result: List[Rule]
    "The list of rules that were generated by the FourFtMiner method."

    def __init__(
            self,
            data: pd.DataFrame,
            rel_antecedent: Cedent,
            rel_succedent: Cedent,
            quantifiers: Sequence[Quantifier],
            relevant_cond: Union[Cedent, None] = None
    ):
        "Initializes the FourFtMiner class."
        self.data = data
        self.rel_antecedent = rel_antecedent
        self.rel_succedent = rel_succedent
        self.quantifiers = quantifiers
        self.relevant_cond = relevant_cond
        self.result = []
        self._run_info = None

        # Divide quantifiers on statistical, founded and base quantifiers
        self._statistical_quantifiers = [q for q in self.quantifiers if isinstance(q, Statistical)]
        self._founded_quantifiers = [q for q in self.quantifiers if isinstance(q, Founded)]
        self._base_quantifiers = [q for q in self.quantifiers if isinstance(q, Base)]

    def print_run_info(self):
        "Prints the information about the last run of the FourFtMiner method."
        if self._run_info is None:
            return

        print(f"FourFtMiner run info:")
        print(f"\tTime start: {self._run_info['time_start']}")
        print(f"\tTime total: {self._run_info['time_total']} seconds")
        print(f"\tNumber of rules: {self._run_info['number_of_rules']}")
        print(f"\tNumber of verifications: {self._run_info['number_of_verifications']}")
        print(f"\tNumber of base verifications: {self._run_info['number_of_base_verifications']}")

    def _restart(self):
        "Restarts the FourFtMiner method."
        self.result = []
        self._run_info = None

    def run(self):
        "Runs the FourFtMiner method based on the given parameters."
        self._restart()
        self._run_info = {
            "time_start": datetime.now(),
            "time_total": 0,
            "number_of_rules": 0,
            "number_of_verifications": 0,
            "number_of_base_verifications": 0,
        }
        print("Starting the task")
        task_run_start = timer()

        print("Calculating bit-form of columns")
        # Get all relevant attributes
        relevant_attributes = []
        for partial_cedents in [self.rel_antecedent.partial_cedents, self.rel_succedent.partial_cedents]:
            for pc in partial_cedents:
                for literal in pc.literals:
                    relevant_attributes.append(literal.attribute)

        attribute_types = self.data[relevant_attributes].dtypes
        cards = pd.get_dummies(self.data[relevant_attributes])

        print("Trees generated")
        # Generate trees for antecedent and succedent
        antecedent_root = generate_cedent(self.data, self.rel_antecedent)
        succedent_root = generate_cedent(self.data, self.rel_succedent)

        print("Calculating rules")
        for antecedent in antecedent_root:
            antecedent_card = get_query_card(cards, antecedent, attribute_types)
            antecedent_count = np.sum(antecedent_card)

            # Does antecedent satisfy base quantifier?
            # If antecedent does not satisfy base quantifier, skip to next antecedent
            self._run_info["number_of_base_verifications"] += 1
            if not self._fullfills_base(antecedent_count):
                # Skip branches that can't fulfill base
                antecedent_root.fullfiled(False)
                continue

            # Reset succedent
            iter(succedent_root)
            for succedent in succedent_root:
                succedent_card = get_query_card(cards, succedent, attribute_types)
                succedent_count = np.sum(succedent_card)

                self._run_info["number_of_base_verifications"] += 1
                if not self._fullfills_base(succedent_count):
                    # Skip branches that can't fulfill base
                    succedent_root.fullfiled(False)
                    continue

                # Calculate quadruple (contingency table)
                # a (E_1,1) - number of rows that satisfy both sides
                a = np.sum(np.logical_and(antecedent_card, succedent_card))
                # b (E_1,0) - number of rows that satisfy left side but not right side
                b = antecedent_count - a
                # c (E_0,1) - number of rows that satisfy right side but not left side
                c = succedent_count - a
                # d (E_0,0) - number of rows that satisfy neither side
                d = self.data.shape[0] - a - b - c

                self._run_info["number_of_verifications"] += 1
                # If frequency a does not satisfy base quantifier, skip to next succedent
                # and if contigency table does not satisfy statistical quantifiers, skip to next succedent
                if not (self._fullfills_base(a) and
                        self._fullfills_statistical([a, b, c, d])):
                    continue

                # Is Prime?
                # TODO: Implement prime verification.

                # Yes? Add to result
                self._run_info["number_of_rules"] += 1
                quantifier = self.quantifiers
                self.result.append(
                    Rule(
                        antecedent,
                        succedent,
                        quantifier,
                        [a, b, c, d],
                    )
                )

        # Postprocessing
        print("Postprocessing")
        self.result = sorted(self.result, reverse=True)
        for rule in self.result:
            rule.posprocessing()

        # End of task
        task_run_stop = timer()
        self._run_info["time_total"] = task_run_stop - task_run_start

        print("End of task")
        return self.result

    def _fullfills_base(self, frequency):
        "Verification of base quantifiers"
        if (all(q.calculate([frequency, 0, 0, 0]) for q in self._base_quantifiers) and
                all(q.base_quantifier.calculate([frequency, 0, 0, 0]) for q in self._founded_quantifiers)):
            return True
        return False

    def _fullfills_statistical(self, quadruple):
        "Verification of statistical quantifiers"
        if all(q.feasibility(quadruple) for q in self._statistical_quantifiers):
            return True
        return False
