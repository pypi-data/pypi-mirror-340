# -*- coding: utf-8 -*-
"""QVP2_20250414_00.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RM9jEfxYpO8wvUXm8M2QZ6KpQUdGizFc

# QuickViper2
Condaå®Ÿè¡Œç’°å¢ƒæ¨©é™ä¸è¶³ã«å¯¾å¿œã™ã‚‹ãŸã‚ã€

1. ä»®æƒ³ç’°å¢ƒã®åœ§ç¸®æ›¸åº«ã‚’ä½œæˆ
2. 1.ã§ã§ããŸåœ§ç¸®æ›¸åº«ã‚’æŒ‡å®šãƒ•ã‚©ãƒ«ãƒ€ã«å±•é–‹

ã‚’è¡Œã†ã€‚



```
2025/03/22 0.1.0 å®Œæˆ
2025/03/22 0.1.1 ãƒã‚°ä¿®æ­£
2025/03/23 0.1.3 DebugHelperã¨ã®ä¾å­˜é–¢ä¿‚ä¿®å¾©ã®ãŸã‚
2025/03/23 0.1.6 ãƒã‚°ä¿®æ­£
2025/03/25 0.1.7 ãƒã‚°ä¿®æ­£
2025/03/25 0.1.8 å„ç¨®ä¿®æ­£ã¨æ”¹è‰¯ã€‚UniqueEnvVar ã‚’å°å…¥
2025/03/26 0.2.0 ãƒ–ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒƒãƒ—ã€‚EasyVen, DebugHelper.installerå°å…¥
2025/03/26 0.2.1 conda_unpackä¿®æ­£ã€‚ä»®æƒ³ç’°å¢ƒã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã§ãã‚‹ã‚ˆã†ã«ãªã‚‹ã€‚
2025/03/27 0.2.2 compress_venv ãƒã‚°ä¿®æ­£
2025/03/31 1.0.0 ç¬¬ä¸€æ¬¡æ”¹è£… CondaInitializerè¿½åŠ  ä»–
2025/03/31 1.0.1 ãƒŸã‚¹
2025/04/01 1.1.0 pack, extract æ”¹è‰¯ãªã©
2025/04/01 1.1.1 extract ä¿®æ­£
2025/04/03 1.2.0 ToolKit åˆ†é›¢
2025/04/14 1.3.0 --ignore-missing-files ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’åˆ©ç”¨å¯èƒ½ã«ã™ã‚‹
```

# QuickViper2

## 1. condacolab èµ·å‹•
### CondaInitializer
- **æ¦‚è¦:** Google Driveæ¥ç¶šã¨ condacolabã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã‚’è¡Œã†
- **ä½¿ç”¨ä¾‹:** ã‚³ãƒ¼ãƒ‰å†’é ­ã«è¨­ç½®ã€‚condacolabã¨å‘¨è¾ºãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒèµ·å‹•ã™ã‚‹ã€‚
"""

# @title a. CondaInitializer å®šç¾© & å®Ÿè¡Œ
from google.colab import drive
drive.mount('/content/drive')
# condacolab èµ·å‹•
get_ipython().system( "pip install -q condacolab" )
import condacolab
get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper


class CondaInitializer:
    def __init__( self ):
        """
        condaã®åˆæœŸè¨­å®šã‚’è¡Œã„ã¾ã™ã€‚
        """
        self.debug = DebugHelper( instance_name = "CondaInitializer")
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()

        # GDriveæ¥ç¶š

        # Colabã§ã¯ "source" ã‚’ä½¿ãˆãªã„ãŸã‚ã€bash -c ã§ conda åˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’çµŒç”±ã™ã‚‹
        self.debug.installer_sync( command = [ "bash", "-c", "source", "/usr/local/etc/profile.d/conda.sh" ], shell = True )

        condacolab.install()
        self.debug.installer_sync( "conda install -q mamba -n base -c conda-forge", shell = True )
        self.debug.installer_sync( "conda install -y -q -c conda-forge conda-pack", shell = True )


if __name__ == "__main__":
    condainit = CondaInitializer()

"""## 2. ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«å®šç¾©"""

# @title a. QuickViper2 å®šç¾©
import os
import re
import json
# import yaml
import shutil
import subprocess

from pathlib import Path

get_ipython().system( "pip install an_DebugHelper" )
from an_debughelper import DebugHelper
get_ipython().system( "pip install an_UniqueEnvVar" )
from an_uniqueenvvar import UniqueEnvVar
get_ipython().system( "pip install an_ToolKit" )
from an_toolkit import ToolKit


class QuickViper2:
    def __init__( self, venv_name, python_version = "3.10" ):
        self.venv_name = venv_name
        self.python_version = python_version

        self.debug = DebugHelper( instance_name = "QuickViper2" )
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()

        self.toolkit = ToolKit()

    def create(self, target):
        """
        æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¹ã« conda ä»®æƒ³ç’°å¢ƒã‚’ä½œæˆã™ã‚‹ã€‚
        args:
            target( str ): ä»®æƒ³ç’°å¢ƒã‚’ä½œæˆã™ã‚‹ãƒ‘ã‚¹
        """
        arg_target = str( target )
        self.debug.log_step(f"Creating conda environment at: { arg_target }", success = None )
        cmd = [
            "conda", "create", "-y", "-q", "-p", arg_target,
            f"python={self.python_version}"
        ]
        # result = subprocess.run(cmd, capture_output=True, text=True)
        result = self.toolkit.executor( cmd = cmd, shell = False )
        if result.returncode != 0:
            raise Exception("Error creating conda environment:")
        else:
            self.debug.log_step("Conda environment created successfully.", success = True )


    def activate( self, target ):
        """
        å±•é–‹ã—ãŸä»®æƒ³ç’°å¢ƒã‚’ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã—ã¾ã™ã€‚
        args:
            target( str ) : ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
        """
        arg_target = str( target )
        self.debug.log_step( "activate", success = None )
        os.chdir( arg_target )
        # result = self.debug.installer( command = f'bash -c "source /usr/local/etc/profile.d/conda.sh && conda activate { arg_target } && exec bash"', shell = True, back = 0 )

        result = self.toolkit.executor( cmd = f'bash -c "source /usr/local/etc/profile.d/conda.sh && conda activate { arg_target } && exec bash"', shell = True )

        if result.returncode == 0:
           self.debug.log_step(f"ç’°å¢ƒãŒã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã«ãªã‚Šã¾ã—ãŸã€‚", char="ğŸŒŸ")


    def pack( self, archive, target, destination ):
        """
        conda-pack ã‚’ä½¿ç”¨ã—ã¦ã€ä»®æƒ³ç’°å¢ƒã‚’ tar.zst å½¢å¼ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«åœ§ç¸®ã—ã¾ã™ã€‚
        args
            archive( str ): åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            archive_zst( str ): zstå½¢å¼åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹(æœªæ•´å‚™)
            target( str ): ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
            destination( str ): å±•é–‹å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        return:
            subprocess.CompletedProcess
        """
        self.debug.log_step("åœ§ç¸®å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™ã€‚", success = None)

        arg_archive = str( archive )
        # arg_archive_zst = arg_archive.replace( ".tar.gz", ".tar.zst" )
        arg_target = str( target )
        arg_destination = str( destination )

        # æ—¢å­˜ã®ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãŒã‚ã‚Œã°å‰Šé™¤ã™ã‚‹
        self.toolkit.file_remover( arg_archive )
        # self.toolkit.file_remover( arg_archive_zst )

        # conda-pack ã§åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹
        cmd = [
            "conda-pack",
            "--prefix", arg_target,
            "--dest-prefix", arg_destination,
            "--format", "tar.gz",
            "--output", arg_archive,
            "--ignore-missing-files"
        ]
        self.toolkit.executor( cmd = cmd )

        # zsrãƒ•ã‚¡ã‚¤ãƒ«ã«äºŒé‡åœ§ç¸®ã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’è¼‰ã›ã¦ãŠããŒã€conda-packãŒzsrãƒ•ã‚¡ã‚¤ãƒ«ã‚’
        # ç›´æ¥å‡ºåŠ›ã§ããªã‘ã‚Œã°çµŒéæ™‚é–“çš„ã«æ„å‘³ãŒãªã„ã®ã§ã€ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆã—ã¦ãŠãã€‚
        # cmd = [
        #     "tar",
        #     "--use-compress-program=zstd",
        #     "-cf", arg_archive_zst,
        #     arg_archive
        # ]
        # self.toolkit.executor( cmd = cmd )


    def extract( self, archive, destination ):
        """
        åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’å±•é–‹ã—ã¾ã™ã€‚
        args:
            archive( str ): åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹
            destination( str ): å±•é–‹å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
        """
        arg_archive = str( archive )
        arg_destination = str( destination )
        self.debug.log_step( "extract", success = None )
        self.toolkit.dir_remover( arg_destination )
        os.makedirs( arg_destination, exist_ok = True )
        # self.debug.installer( command = f"tar -xf { arg_archive } -C { arg_destination }", shell = True, back = 1 )
        cmd = [ "tar",
                "-xf",  arg_archive,
                "-C",   arg_destination ]
        self.toolkit.executor( cmd = cmd )

    # def list_archive( self ):
    #     """
    #     ä»®æƒ³ç’°å¢ƒã®ãƒªã‚¹ãƒˆã‚’ä½œæˆã—ã¾ã™ã€‚
    #     """
    #     self.debug.log_step( "list_archive", success = None )
    #     get_ipython().system( f"tar tvf { self.arc_path }" )
    #     self.debug.installer( command = [ "tar", "tvf", str(self.arc_path ) ] )

    def delete_venv( self, target ):
        """
        ä»®æƒ³ç’°å¢ƒã‚’æ¶ˆå»ã—ã¾ã™
        args:
            target( str ): æ¶ˆå»ã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
        """
        self.debug.log_step( "delete_venv", success = None )
        arg_target = str( target )
        self.toolkit.dir_remover( arg_target )


    def set_executable( self, target ):
        """
        å®Ÿè¡Œæ¨©é™ã‚’ä¿®æ­£ã—ã¾ã™ã€‚
        args:
            target( str ): å®Ÿè¡Œæ¨©é™ã‚’ä¿®æ­£ã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
        """
        self.debug.log_step( "set_executable", success = None )
        arg_target = Path( target ).joinpath( "bin" )
        python3_path =  arg_target / "python3.10"
        python_link = arg_target / "python"
        os.chmod(python3_path, 0o755)
        os.chmod(python_link, 0o755)
        # self.debug.installer( command = f"ls -l { python3_path }", shell = True)
        # self.debug.installer( command = f"ls -l { python_link }", shell = True)
        self.toolkit.executor( cmd = f"ls -l { python3_path }", shell = True, log = True )
        self.toolkit.executor( cmd = f"ls -l { python_link }", shell = True, log = True )


    def set_env_var( self, target ):
        """
        ä½œæˆã—ãŸç’°å¢ƒå†…ã®ç’°å¢ƒå¤‰æ•°ã‚’å®šç¾©ã™ã‚‹ã€‚
        args:
            target( str ): åˆ©ç”¨ã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ‘ã‚¹
        """
        arg_target = str ( Path( target ).joinpath( "bin" ) )
        arg_library = str( Path( target ).joinpath( "lib" ) )
        ue_path = UniqueEnvVar( "PATH" )
        ue_ld_library_path = UniqueEnvVar( "LD_LIBRARY_PATH" )
        ue_path.add_value( arg_target )
        ue_ld_library_path.add_value( arg_library )
        self.debug.log_step( f"PATH : { ue_path.get_values() }" )
        self.debug.log_step( f"LD_LIBRARY_PATH : { ue_ld_library_path.get_values() }" )


    def unlock( self, archive, destination, force_unlock = False ):
        """
        åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’å±•é–‹ã—ã¾ã™ã€‚
        args:
            archive( str ): å±•é–‹ã™ã‚‹åœ§ç¸®ä»®æƒ³ç’°å¢ƒãƒ•ã‚¡ã‚¤ãƒ«
            destination( str ): å±•é–‹å…ˆãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒª
            force_unlock( boolean ): Trueã®ã¨ãã€å¼·åˆ¶çš„ã«å±•é–‹ã—ã¾ã™ã€‚
        """
        self.debug.log_step( "unlock", success = None )
        arg_archive = str( archive )
        arg_destination = str( destination )
        if force_unlock and Path( arg_destination ).exists():
            shutil.rmtree( arg_destination )
        if not Path( arg_destination ).exists():
            self.extract( archive = arg_archive, destination = arg_destination )
            self.activate( target = arg_destination )
            self.set_executable( target = arg_destination )
            self.set_env_var( target = arg_destination )

    def executor( self, target, cmdlist = [ "pip", "--version" ], log = False ):
        """
        ä»®æƒ³ç’°å¢ƒã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã‚’å®Ÿè¡Œã—ã¾ã™ã€‚
        args:
            target( str ): ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹ä»®æƒ³ç’°å¢ƒã®ãƒ•ã‚©ãƒ«ãƒ€
            cmdlist( str [] ): å®Ÿè¡Œã™ã‚‹ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®ã‚³ãƒãƒ³ãƒ‰ãƒ©ã‚¤ãƒ³
        """
        self.debug.log_step( "exe_python", success = None )
        arg_target = str( Path( target ).joinpath( "bin" ) )
        os.chdir( arg_target )
        # ç¾åœ¨ã®ç’°å¢ƒå¤‰æ•°ã‚’ã‚³ãƒ”ãƒ¼
        env = os.environ.copy()
        # ã‚·ã‚§ãƒ«ã‚’ä½¿ã£ã¦ "env | grep LD_LIBRARY_PATH" ã‚’å®Ÿè¡Œã—ã€å‡ºåŠ›ã‚’ã‚­ãƒ£ãƒ—ãƒãƒ£
        # result = subprocess.run(["env"], env=env, capture_output=True, text=True)
        # result = subprocess.run("env | grep ^LD_LIBRARY_PATH=", shell=True, env=env, capture_output=True, text=True)
        result = self.toolkit.executor( cmd = "env | grep LD_LIBRARY_PATH", shell = True )
        self.debug.log_step( f"result : { result }", success = None )
        # å®Ÿè¡Œã‚³ãƒãƒ³ãƒ‰ã‚’ãƒªã‚¹ãƒˆå½¢å¼ã§å®šç¾©
        pre_cmd = [ str( Path( arg_target ).joinpath( "python" ) ), "-m" ]
        self.toolkit.executor( cmd = pre_cmd + cmdlist, log = True )
        ### self.debug.run.commandãŒä½¿ãˆãªã„ç†ç”±ã¯ã‚ã‹ã‚‰ãªã„ã€‚ã“ã‚Œã‚‚ä»®æƒ³ç’°å¢ƒçµ¡ã¿ã‹?
        ### result, stdout, stderr = self.debug.run_command( command = full_cmd, stdout = True, stderr = True )
        ### self.debug.log_step( f"stdout:\n{ stdout }", success = None)
        ### self.debug.log_step( f"stderr:\n{ stdout }", success = None)

get_ipython().system( "pip install an_EasyVen" )
from an_easyven import EasyVen


# @title b. Mainloop å®šç¾©
class MainLoop():
    def __init__( self, venv_name = "kohya_env" ):
        """
        ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
        """
        self.debug = DebugHelper( instance_name = "MainLoop" )
        self.debug.enable_log_to_file_stdout()
        self.debug.enable_log_to_file_stderr()
        self.debug.enable_timestamp()

        self.venv_name = venv_name
        self.even = EasyVen()
        [ self.bch_path,
          self.dst_path,
          self.cur_path,
          self.src_path,
          self.arc_path,
          self.arz_path,
          self.lcl_path,
          self.bin_path,
          self.lib_path,
          self.tmp_path,
          self.org_path,
          self.orz_path,
          self.enva_path ] = self.even.setup( venv_name = self.venv_name )

        self.quickviper = QuickViper2( venv_name = self.venv_name )

    def remove_temp_env(self):
        """
        æ—¢å­˜ã®ç’°å¢ƒãŒã‚ã‚Œã°å‰Šé™¤
        """
        self.quickviper.delete_venv( target = self.tmp_path )


    def create_temp_env(self):
        """
        ä¸€æ™‚çš„ãªç’°å¢ƒã‚’ä½œæˆ
        """
        # ã‚¯ãƒ©ã‚¹ã‚’ä½¿ã£ã¦ç’°å¢ƒã®ä½œæˆã€conda-pack ã®ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã€conda-unpack ã®ç¢ºèªã‚’å®Ÿæ–½
        self.quickviper.create( target = self.tmp_path )

    def pack_temp_env(self):
        """
        ä¸€æ™‚çš„ãªç’°å¢ƒã‚’åœ§ç¸®
        """
        self.quickviper.pack( archive = self.org_path, target = self.tmp_path, destination = self.lcl_path )

    def unpack_temp_env(self):
        """
        ä¸€æ™‚çš„ãªç’°å¢ƒã‚’å±•é–‹
        """
        self.quickviper.unlock( archive = self.org_path, destination = self.lcl_path, force_unlock = True )


    def executor( self ):
        """
        pipã‚’ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        """
        self.quickviper.executor( target = self.lcl_path, log = True )

"""# 3. ãƒ†ã‚¹ãƒˆ"""

# @title a. MainLoop å®Ÿè¡Œ
if __name__ == "__main__":
    mainloop = MainLoop()
    mainloop.remove_temp_env()
    mainloop.create_temp_env()
    mainloop.pack_temp_env()
    mainloop.unpack_temp_env()
    mainloop.executor()