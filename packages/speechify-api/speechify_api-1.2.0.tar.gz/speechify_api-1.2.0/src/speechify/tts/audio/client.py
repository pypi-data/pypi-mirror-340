# This file was auto-generated by Fern from our API Definition.

import typing
from ...core.client_wrapper import SyncClientWrapper
from .types.get_speech_request_audio_format import GetSpeechRequestAudioFormat
from .types.get_speech_request_model import GetSpeechRequestModel
from ..types.get_speech_options_request import GetSpeechOptionsRequest
from ...core.request_options import RequestOptions
from ..types.get_speech_response import GetSpeechResponse
from ...core.serialization import convert_and_respect_annotation_metadata
from ...core.pydantic_utilities import parse_obj_as
from ..errors.bad_request_error import BadRequestError
from ..errors.payment_required_error import PaymentRequiredError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from json.decoder import JSONDecodeError
from ...core.api_error import ApiError
from .types.audio_stream_request_accept import AudioStreamRequestAccept
from .types.get_stream_request_model import GetStreamRequestModel
from ..types.get_stream_options_request import GetStreamOptionsRequest
from ...core.client_wrapper import AsyncClientWrapper

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class AudioClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def speech(
        self,
        *,
        input: str,
        voice_id: str,
        audio_format: typing.Optional[GetSpeechRequestAudioFormat] = OMIT,
        language: typing.Optional[str] = OMIT,
        model: typing.Optional[GetSpeechRequestModel] = OMIT,
        options: typing.Optional[GetSpeechOptionsRequest] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetSpeechResponse:
        """
        Gets the speech data for the given input

        Parameters
        ----------
        input : str
            Plain text or SSML to be synthesized to speech.
            Refer to https://docs.sws.speechify.com/docs/api-limits for the input size limits.
            Emotion, Pitch and Speed Rate are configured in the ssml input, please refer to the ssml documentation for more information: https://docs.sws.speechify.com/docs/ssml#prosody

        voice_id : str
            Id of the voice to be used for synthesizing speech. Refer to /v1/voices endpoint for available voices

        audio_format : typing.Optional[GetSpeechRequestAudioFormat]
            The format for the output audio. Note, that the current default is "wav", but there's no guarantee it will not change in the future. We recommend always passing the specific param you expect.

        language : typing.Optional[str]
            Language of the input. Follow the format of an ISO 639-1 language code and an ISO 3166-1 region code, separated by a hyphen, e.g. en-US.
            Please refer to the list of the supported languages and recommendations regarding this parameter: https://docs.sws.speechify.com/docs/language-support.

        model : typing.Optional[GetSpeechRequestModel]
            Model used for audio synthesis. `simba-base` and `simba-turbo` are deprecated. Use `simba-english` or `simba-multilingual` instead.

        options : typing.Optional[GetSpeechOptionsRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSpeechResponse


        Examples
        --------
        from speechify import Speechify

        client = Speechify(
            token="YOUR_TOKEN",
        )
        client.tts.audio.speech(
            input="input",
            voice_id="voice_id",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v1/audio/speech",
            method="POST",
            json={
                "audio_format": audio_format,
                "input": input,
                "language": language,
                "model": model,
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=GetSpeechOptionsRequest, direction="write"
                ),
                "voice_id": voice_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetSpeechResponse,
                    parse_obj_as(
                        type_=GetSpeechResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 402:
                raise PaymentRequiredError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stream(
        self,
        *,
        accept: AudioStreamRequestAccept,
        input: str,
        voice_id: str,
        language: typing.Optional[str] = OMIT,
        model: typing.Optional[GetStreamRequestModel] = OMIT,
        options: typing.Optional[GetStreamOptionsRequest] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[bytes]:
        """
        Gets the stream speech for the given input

        Parameters
        ----------
        accept : AudioStreamRequestAccept

        input : str
            Plain text or SSML to be synthesized to speech.
            Refer to https://docs.sws.speechify.com/docs/api-limits for the input size limits.
            Emotion, Pitch and Speed Rate are configured in the ssml input, please refer to the ssml documentation for more information: https://docs.sws.speechify.com/docs/ssml#prosody

        voice_id : str
            Id of the voice to be used for synthesizing speech. Refer to /v1/voices endpoint for available voices

        language : typing.Optional[str]
            Language of the input. Follow the format of an ISO 639-1 language code and an ISO 3166-1 region code, separated by a hyphen, e.g. en-US.
            Please refer to the list of the supported languages and recommendations regarding this parameter: https://docs.sws.speechify.com/docs/language-support.

        model : typing.Optional[GetStreamRequestModel]
            Model used for audio synthesis. `simba-base` and `simba-turbo` are deprecated. Use `simba-english` or `simba-multilingual` instead.

        options : typing.Optional[GetStreamOptionsRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.Iterator[bytes]

        """
        with self._client_wrapper.httpx_client.stream(
            "v1/audio/stream",
            method="POST",
            json={
                "input": input,
                "language": language,
                "model": model,
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=GetStreamOptionsRequest, direction="write"
                ),
                "voice_id": voice_id,
            },
            headers={
                "content-type": "application/json",
                "Accept": str(accept) if accept is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                    for _chunk in _response.iter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                _response.read()
                if _response.status_code == 400:
                    raise BadRequestError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                if _response.status_code == 402:
                    raise PaymentRequiredError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                if _response.status_code == 500:
                    raise InternalServerError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncAudioClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def speech(
        self,
        *,
        input: str,
        voice_id: str,
        audio_format: typing.Optional[GetSpeechRequestAudioFormat] = OMIT,
        language: typing.Optional[str] = OMIT,
        model: typing.Optional[GetSpeechRequestModel] = OMIT,
        options: typing.Optional[GetSpeechOptionsRequest] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> GetSpeechResponse:
        """
        Gets the speech data for the given input

        Parameters
        ----------
        input : str
            Plain text or SSML to be synthesized to speech.
            Refer to https://docs.sws.speechify.com/docs/api-limits for the input size limits.
            Emotion, Pitch and Speed Rate are configured in the ssml input, please refer to the ssml documentation for more information: https://docs.sws.speechify.com/docs/ssml#prosody

        voice_id : str
            Id of the voice to be used for synthesizing speech. Refer to /v1/voices endpoint for available voices

        audio_format : typing.Optional[GetSpeechRequestAudioFormat]
            The format for the output audio. Note, that the current default is "wav", but there's no guarantee it will not change in the future. We recommend always passing the specific param you expect.

        language : typing.Optional[str]
            Language of the input. Follow the format of an ISO 639-1 language code and an ISO 3166-1 region code, separated by a hyphen, e.g. en-US.
            Please refer to the list of the supported languages and recommendations regarding this parameter: https://docs.sws.speechify.com/docs/language-support.

        model : typing.Optional[GetSpeechRequestModel]
            Model used for audio synthesis. `simba-base` and `simba-turbo` are deprecated. Use `simba-english` or `simba-multilingual` instead.

        options : typing.Optional[GetSpeechOptionsRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        GetSpeechResponse


        Examples
        --------
        import asyncio

        from speechify import AsyncSpeechify

        client = AsyncSpeechify(
            token="YOUR_TOKEN",
        )


        async def main() -> None:
            await client.tts.audio.speech(
                input="input",
                voice_id="voice_id",
            )


        asyncio.run(main())
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v1/audio/speech",
            method="POST",
            json={
                "audio_format": audio_format,
                "input": input,
                "language": language,
                "model": model,
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=GetSpeechOptionsRequest, direction="write"
                ),
                "voice_id": voice_id,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                return typing.cast(
                    GetSpeechResponse,
                    parse_obj_as(
                        type_=GetSpeechResponse,  # type: ignore
                        object_=_response.json(),
                    ),
                )
            if _response.status_code == 400:
                raise BadRequestError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 402:
                raise PaymentRequiredError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    )
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stream(
        self,
        *,
        accept: AudioStreamRequestAccept,
        input: str,
        voice_id: str,
        language: typing.Optional[str] = OMIT,
        model: typing.Optional[GetStreamRequestModel] = OMIT,
        options: typing.Optional[GetStreamOptionsRequest] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[bytes]:
        """
        Gets the stream speech for the given input

        Parameters
        ----------
        accept : AudioStreamRequestAccept

        input : str
            Plain text or SSML to be synthesized to speech.
            Refer to https://docs.sws.speechify.com/docs/api-limits for the input size limits.
            Emotion, Pitch and Speed Rate are configured in the ssml input, please refer to the ssml documentation for more information: https://docs.sws.speechify.com/docs/ssml#prosody

        voice_id : str
            Id of the voice to be used for synthesizing speech. Refer to /v1/voices endpoint for available voices

        language : typing.Optional[str]
            Language of the input. Follow the format of an ISO 639-1 language code and an ISO 3166-1 region code, separated by a hyphen, e.g. en-US.
            Please refer to the list of the supported languages and recommendations regarding this parameter: https://docs.sws.speechify.com/docs/language-support.

        model : typing.Optional[GetStreamRequestModel]
            Model used for audio synthesis. `simba-base` and `simba-turbo` are deprecated. Use `simba-english` or `simba-multilingual` instead.

        options : typing.Optional[GetStreamOptionsRequest]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration. You can pass in configuration such as `chunk_size`, and more to customize the request and response.

        Yields
        ------
        typing.AsyncIterator[bytes]

        """
        async with self._client_wrapper.httpx_client.stream(
            "v1/audio/stream",
            method="POST",
            json={
                "input": input,
                "language": language,
                "model": model,
                "options": convert_and_respect_annotation_metadata(
                    object_=options, annotation=GetStreamOptionsRequest, direction="write"
                ),
                "voice_id": voice_id,
            },
            headers={
                "content-type": "application/json",
                "Accept": str(accept) if accept is not None else None,
            },
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            try:
                if 200 <= _response.status_code < 300:
                    _chunk_size = request_options.get("chunk_size", None) if request_options is not None else None
                    async for _chunk in _response.aiter_bytes(chunk_size=_chunk_size):
                        yield _chunk
                    return
                await _response.aread()
                if _response.status_code == 400:
                    raise BadRequestError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                if _response.status_code == 402:
                    raise PaymentRequiredError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                if _response.status_code == 403:
                    raise ForbiddenError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                if _response.status_code == 500:
                    raise InternalServerError(
                        typing.cast(
                            typing.Optional[typing.Any],
                            parse_obj_as(
                                type_=typing.Optional[typing.Any],  # type: ignore
                                object_=_response.json(),
                            ),
                        )
                    )
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)
