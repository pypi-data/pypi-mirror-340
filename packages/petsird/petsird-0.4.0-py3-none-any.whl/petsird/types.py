# This file was generated by the "yardl" tool. DO NOT EDIT.

# pyright: reportUnusedImport=false
# pyright: reportUnknownArgumentType=false
# pyright: reportUnknownMemberType=false
# pyright: reportUnknownVariableType=false

import datetime
import enum
import types
import typing

import numpy as np
import numpy.typing as npt

from . import yardl_types as yardl
from . import _dtypes


Shape = typing.TypeVar("Shape")
Shape_NP = typing.TypeVar("Shape_NP", bound=np.generic)
T = typing.TypeVar("T")
T_NP = typing.TypeVar("T_NP", bound=np.generic)


DetElIdx = yardl.UInt32
"""This is the type for the index over "detection elements" (aka "crystals"), e.g. used in `DetectionBin`
It is an unsigned integer that runs over all the "detector elements" starting from 0.

The correspondence between this integer and a module/det_el is not encoded in this model,
but only in the "helpers".
It corresponds to effectively incrementing the detElIdx in nested loops:
1. ScannerGeometry.replicated_modules
2. replicated_module.transforms
3. replicated_module.detecting_elements
4. detecting_element.transforms
(with the detElIdx running faster over the 4th loop)
"""


class DetectionBin:
    """type for a "single" detection, used in `CoincidenceEvent` and `TripleEvent`."""

    det_el_idx: DetElIdx
    """the elementary detector element, see DetElIdx"""

    energy_idx: yardl.UInt32
    """index (starting from 0) for the energy window
    See the ScannerInformation.eventEnergyBinEdges field
    """


    def __init__(self, *,
        det_el_idx: DetElIdx = 0,
        energy_idx: yardl.UInt32 = 0,
    ):
        self.det_el_idx = det_el_idx
        self.energy_idx = energy_idx

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, DetectionBin)
            and self.det_el_idx == other.det_el_idx
            and self.energy_idx == other.energy_idx
        )

    def __str__(self) -> str:
        return f"DetectionBin(detElIdx={self.det_el_idx}, energyIdx={self.energy_idx})"

    def __repr__(self) -> str:
        return f"DetectionBin(detElIdx={repr(self.det_el_idx)}, energyIdx={repr(self.energy_idx)})"


class CoincidenceEvent:
    """All information about a coincidence event specified as indices (i.e. discretized)."""

    detection_bins: list[DetectionBin]
    """identifiers of the two detecting elements (see doc for DetectionBin)"""

    tof_idx: yardl.UInt32
    """an index into the tofBinEdges field in the ScannerInformation"""


    def __init__(self, *,
        detection_bins: typing.Optional[list[DetectionBin]] = None,
        tof_idx: yardl.UInt32 = 0,
    ):
        self.detection_bins = detection_bins if detection_bins is not None else [DetectionBin() for _ in range(2)]
        self.tof_idx = tof_idx

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, CoincidenceEvent)
            and self.detection_bins == other.detection_bins
            and self.tof_idx == other.tof_idx
        )

    def __str__(self) -> str:
        return f"CoincidenceEvent(detectionBins={self.detection_bins}, tofIdx={self.tof_idx})"

    def __repr__(self) -> str:
        return f"CoincidenceEvent(detectionBins={repr(self.detection_bins)}, tofIdx={repr(self.tof_idx)})"


SGID = yardl.UInt32
"""Symmetry Group Identifier Type
Most PET scanners have some kind of geometric symmetry, e.g. rotation over a full
module, or translation along the axis of the scanner. Module-pairs that are related
by such a symmetry often have the same geometric detection efficiencies. PETSIRD
calls this a "symmetry group" (SG). Each SG had a unique identifier (SGID).
SGIDs are used to efficiently encode module-pair efficiencies etc.
"""


DetectionBinEfficiencies = npt.NDArray[np.float32]
"""Detection efficiencies for every DetectionBin
If size along energyBinIdx is 1, the effiencies are assumed to be the same for every energy bin.
Constraint: size(DetectionBinEfficiencies, "energyBinIdx") == scannerInformation.numberOfEventEnergyBins or 1
"""


class ModulePairEfficiencies:
    """Efficiency for two detection bins in a pair of modules.
    This is one component (often called "geometric") of the detection efficiency model.
    If size along energyBinIdx is 1, the effiencies are assumed to be the same for every energy bin.
    """

    values: npt.NDArray[np.float32]
    """Detection efficiency for a pair of detection bins
    detElIdx1 and detElIdx2 run from 0 to the number of det_els in each module
    """

    sgid: SGID
    """Symmetry Group Identifier (SGID)
    This should be a number between 0 and numberOfSGIDs-1
    """


    def __init__(self, *,
        values: typing.Optional[npt.NDArray[np.float32]] = None,
        sgid: SGID = 0,
    ):
        self.values = values if values is not None else np.zeros((0, 0, 0, 0), dtype=np.dtype(np.float32))
        self.sgid = sgid

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ModulePairEfficiencies)
            and yardl.structural_equal(self.values, other.values)
            and self.sgid == other.sgid
        )

    def __str__(self) -> str:
        return f"ModulePairEfficiencies(values={self.values}, sgid={self.sgid})"

    def __repr__(self) -> str:
        return f"ModulePairEfficiencies(values={repr(self.values)}, sgid={repr(self.sgid)})"


ModulePairSGIDLUT = npt.NDArray[np.int32]
"""Lookup table for SGIDs
For every module pair, give the SGID. If -1, the module-pair is not in coincidence.
Values run from -1 ... (numberOfSGIDs-1)
"""


ModulePairEfficienciesVector = list[ModulePairEfficiencies]

class DetectionEfficiencies:
    """Component-based information on detection efficiencies
    This encodes a simple model for the detection efficiency of (true) coincidences
    consisting of the product of the efficiency of the two detection bins
    and a (geometric) component determined by their location in the two modules.
    The former are stored in detectionBinEfficiencies, and the latter in modulePairEfficienciesVector
    (a list of ModulePairEfficiencies, each entry corresponding to a module pair).

    To save memory, the modulePairEfficienciesVector contains only one of element for each SGID.
    The SGID for a module-pair can be found in modulePairSGIDLUT.

    Finding the total detection efficiency therefore follows these steps in pseudo-code
    1. find modules for each detection_bin
    2. find det_el indices "inside" each module
    3. SGID = modulePairSGIDLUT[mod1, mod1]
    4. if (SGID < 0) return 0
    5. module_pair_efficiencies = modulePairEfficienciesVector[SGID]
    6. return detectionBinEfficiencies(detection_bin1) * detectionBinEfficiencies(detection_bin2)
          * module_pair_efficiencies[det_el_in_mod1, en1, det_el_in_mod2, en2]

    If either of the components is not present, its value is considered to be 1.
    """

    detection_bin_efficiencies: typing.Optional[DetectionBinEfficiencies]
    """Detection efficiencies for every detection bin"""

    module_pair_sgidlut: typing.Optional[ModulePairSGIDLUT]
    """Lookup table for SGIDs.
    Also indicates if coincidences between a module-pair are recorded.
    """

    module_pair_efficiencies_vector: typing.Optional[ModulePairEfficienciesVector]
    """Vector of all modulePairEfficiencies (one for each SGID)
    Constraint: size(modulePairEfficienciesVector) == max(modulePairSGIDLUT) + 1
    """


    def __init__(self, *,
        detection_bin_efficiencies: typing.Optional[DetectionBinEfficiencies] = None,
        module_pair_sgidlut: typing.Optional[ModulePairSGIDLUT] = None,
        module_pair_efficiencies_vector: typing.Optional[ModulePairEfficienciesVector] = None,
    ):
        self.detection_bin_efficiencies = detection_bin_efficiencies
        self.module_pair_sgidlut = module_pair_sgidlut
        self.module_pair_efficiencies_vector = module_pair_efficiencies_vector

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, DetectionEfficiencies)
            and (other.detection_bin_efficiencies is None if self.detection_bin_efficiencies is None else (other.detection_bin_efficiencies is not None and yardl.structural_equal(self.detection_bin_efficiencies, other.detection_bin_efficiencies)))
            and (other.module_pair_sgidlut is None if self.module_pair_sgidlut is None else (other.module_pair_sgidlut is not None and yardl.structural_equal(self.module_pair_sgidlut, other.module_pair_sgidlut)))
            and (other.module_pair_efficiencies_vector is None if self.module_pair_efficiencies_vector is None else (other.module_pair_efficiencies_vector is not None and len(self.module_pair_efficiencies_vector) == len(other.module_pair_efficiencies_vector) and all(a == b for a, b in zip(self.module_pair_efficiencies_vector, other.module_pair_efficiencies_vector))))
        )

    def __str__(self) -> str:
        return f"DetectionEfficiencies(detectionBinEfficiencies={self.detection_bin_efficiencies}, modulePairSGIDLUT={self.module_pair_sgidlut}, modulePairEfficienciesVector={self.module_pair_efficiencies_vector})"

    def __repr__(self) -> str:
        return f"DetectionEfficiencies(detectionBinEfficiencies={repr(self.detection_bin_efficiencies)}, modulePairSGIDLUT={repr(self.module_pair_sgidlut)}, modulePairEfficienciesVector={repr(self.module_pair_efficiencies_vector)})"


class SolidVolume(typing.Generic[Shape]):
    """A shape filled with a uniform material"""

    shape: Shape
    material_id: yardl.UInt32
    """identifier referring to `ScannerInformation.bulkMaterials` list"""


    def __init__(self, *,
        shape: Shape,
        material_id: yardl.UInt32 = 0,
    ):
        self.shape = shape
        self.material_id = material_id

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SolidVolume)
            and yardl.structural_equal(self.shape, other.shape)
            and self.material_id == other.material_id
        )

    def __str__(self) -> str:
        return f"SolidVolume(shape={self.shape}, materialId={self.material_id})"

    def __repr__(self) -> str:
        return f"SolidVolume(shape={repr(self.shape)}, materialId={repr(self.material_id)})"


class Coordinate:
    """3D coordinates (in mm)"""

    c: npt.NDArray[np.float32]

    def __init__(self, *,
        c: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.c = c if c is not None else np.zeros((3,), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Coordinate)
            and yardl.structural_equal(self.c, other.c)
        )

    def __str__(self) -> str:
        return f"Coordinate(c={self.c})"

    def __repr__(self) -> str:
        return f"Coordinate(c={repr(self.c)})"


class BoxShape:
    """A box-shape specified by 8 corners (e.g. cuboid, wedge, etc.)
    TODO need to think about a clear definition of planes
    We do not want to have to check about intersection planes
    Potential mechanisms:
    - lexicographical ordering of corner coordinates?
    - first 4 coordinates give first plane, 5th and 6th need to define plane with first 2, etc.
    """

    corners: list[Coordinate]

    def __init__(self, *,
        corners: typing.Optional[list[Coordinate]] = None,
    ):
        self.corners = corners if corners is not None else [Coordinate() for _ in range(8)]

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, BoxShape)
            and len(self.corners) == len(other.corners) and all(a == b for a, b in zip(self.corners, other.corners))
        )

    def __str__(self) -> str:
        return f"BoxShape(corners={self.corners})"

    def __repr__(self) -> str:
        return f"BoxShape(corners={repr(self.corners)})"


BoxSolidVolume = SolidVolume[BoxShape]

class AnnulusShape:
    """Annulus of certain thickness centered at [0,0,0] and oriented along the [0,0,1] axis
    in radians. An angle of 0 corresponds to the [1,0,0] axis, Pi/2 corresponds to the [0,1,0] axis.
    """

    inner_radius: yardl.Float32
    """inner radius (in mm)"""

    outer_radius: yardl.Float32
    """outer radius (in mm)"""

    thickness: yardl.Float32
    """thickness of the annulus, i.e. length along the axis (in mm)"""

    angular_range: list[yardl.Float32]
    """start-stop angle (in radians)"""


    def __init__(self, *,
        inner_radius: yardl.Float32 = 0.0,
        outer_radius: yardl.Float32 = 0.0,
        thickness: yardl.Float32 = 0.0,
        angular_range: typing.Optional[list[yardl.Float32]] = None,
    ):
        self.inner_radius = inner_radius
        self.outer_radius = outer_radius
        self.thickness = thickness
        self.angular_range = angular_range if angular_range is not None else [0.0] * 2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, AnnulusShape)
            and self.inner_radius == other.inner_radius
            and self.outer_radius == other.outer_radius
            and self.thickness == other.thickness
            and self.angular_range == other.angular_range
        )

    def __str__(self) -> str:
        return f"AnnulusShape(innerRadius={self.inner_radius}, outerRadius={self.outer_radius}, thickness={self.thickness}, angularRange={self.angular_range})"

    def __repr__(self) -> str:
        return f"AnnulusShape(innerRadius={repr(self.inner_radius)}, outerRadius={repr(self.outer_radius)}, thickness={repr(self.thickness)}, angularRange={repr(self.angular_range)})"


_T = typing.TypeVar('_T')

class GeometricShape:
    BoxShape: typing.ClassVar[type["GeometricShapeUnionCase[BoxShape]"]]
    AnnulusShape: typing.ClassVar[type["GeometricShapeUnionCase[AnnulusShape]"]]

class GeometricShapeUnionCase(GeometricShape, yardl.UnionCase[_T]):
    pass

GeometricShape.BoxShape = type("GeometricShape.BoxShape", (GeometricShapeUnionCase,), {"index": 0, "tag": "BoxShape"})
GeometricShape.AnnulusShape = type("GeometricShape.AnnulusShape", (GeometricShapeUnionCase,), {"index": 1, "tag": "AnnulusShape"})
del GeometricShapeUnionCase

GenericSolidVolume = SolidVolume[GeometricShape]

class RigidTransformation:
    """Rigid transformation, encoded via homogenous transformation
    transformed_coord = matrix * [c, 1] (where [c,1] is a column vector)
    with `c` of type `Coordinate`
    """

    matrix: npt.NDArray[np.float32]

    def __init__(self, *,
        matrix: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.matrix = matrix if matrix is not None else np.zeros((3, 4,), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, RigidTransformation)
            and yardl.structural_equal(self.matrix, other.matrix)
        )

    def __str__(self) -> str:
        return f"RigidTransformation(matrix={self.matrix})"

    def __repr__(self) -> str:
        return f"RigidTransformation(matrix={repr(self.matrix)})"


class ReplicatedObject(typing.Generic[T]):
    """A list of identical objects at different locations"""

    object: T
    transforms: list[RigidTransformation]
    """list of transforms
    constraint: length >= 1
    """


    def __init__(self, *,
        object: T,
        transforms: typing.Optional[list[RigidTransformation]] = None,
    ):
        self.object = object
        self.transforms = transforms if transforms is not None else []

    def number_of_objects(self) -> yardl.Size:
        return len(self.transforms)

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ReplicatedObject)
            and yardl.structural_equal(self.object, other.object)
            and len(self.transforms) == len(other.transforms) and all(a == b for a, b in zip(self.transforms, other.transforms))
        )

    def __str__(self) -> str:
        return f"ReplicatedObject(object={self.object}, transforms={self.transforms})"

    def __repr__(self) -> str:
        return f"ReplicatedObject(object={repr(self.object)}, transforms={repr(self.transforms)})"


ReplicatedBoxSolidVolume = ReplicatedObject[BoxSolidVolume]
"""A list of identical SolidVolumes<BoxShape> at different locations"""


ReplicatedGenericSolidVolume = ReplicatedObject[GenericSolidVolume]
"""A list of identical SolidVolumes<BGeometricShape> at different locations"""


class DetectorModule:
    """Top-level detector structure, consisting of one or more lists of detecting elements (or "crystals")
    This allows having different types of detecting elements (e.g. for phoswich detectors)
    """

    detecting_elements: list[ReplicatedBoxSolidVolume]
    non_detecting_elements: list[ReplicatedGenericSolidVolume]
    """optional list describing shielding/optical reflectors etc"""


    def __init__(self, *,
        detecting_elements: typing.Optional[list[ReplicatedBoxSolidVolume]] = None,
        non_detecting_elements: typing.Optional[list[ReplicatedGenericSolidVolume]] = None,
    ):
        self.detecting_elements = detecting_elements if detecting_elements is not None else []
        self.non_detecting_elements = non_detecting_elements if non_detecting_elements is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, DetectorModule)
            and len(self.detecting_elements) == len(other.detecting_elements) and all(a == b for a, b in zip(self.detecting_elements, other.detecting_elements))
            and len(self.non_detecting_elements) == len(other.non_detecting_elements) and all(a == b for a, b in zip(self.non_detecting_elements, other.non_detecting_elements))
        )

    def __str__(self) -> str:
        return f"DetectorModule(detectingElements={self.detecting_elements}, nonDetectingElements={self.non_detecting_elements})"

    def __repr__(self) -> str:
        return f"DetectorModule(detectingElements={repr(self.detecting_elements)}, nonDetectingElements={repr(self.non_detecting_elements)})"


ReplicatedDetectorModule = ReplicatedObject[DetectorModule]
"""A list of identical modules at different locations"""


class ScannerGeometry:
    """Full definition of the geometry of the scanner, consisting of
    one of more types of modules replicated in space and (optional) other structures (e.g. side-shielding)
    """

    replicated_modules: list[ReplicatedDetectorModule]
    """list of different types of replicated modules"""

    non_detecting_volumes: typing.Optional[list[GenericSolidVolume]]
    """shielding etc"""


    def __init__(self, *,
        replicated_modules: typing.Optional[list[ReplicatedDetectorModule]] = None,
        non_detecting_volumes: typing.Optional[list[GenericSolidVolume]] = None,
    ):
        self.replicated_modules = replicated_modules if replicated_modules is not None else []
        self.non_detecting_volumes = non_detecting_volumes

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ScannerGeometry)
            and len(self.replicated_modules) == len(other.replicated_modules) and all(a == b for a, b in zip(self.replicated_modules, other.replicated_modules))
            and (other.non_detecting_volumes is None if self.non_detecting_volumes is None else (other.non_detecting_volumes is not None and len(self.non_detecting_volumes) == len(other.non_detecting_volumes) and all(a == b for a, b in zip(self.non_detecting_volumes, other.non_detecting_volumes))))
        )

    def __str__(self) -> str:
        return f"ScannerGeometry(replicatedModules={self.replicated_modules}, nonDetectingVolumes={self.non_detecting_volumes})"

    def __repr__(self) -> str:
        return f"ScannerGeometry(replicatedModules={repr(self.replicated_modules)}, nonDetectingVolumes={repr(self.non_detecting_volumes)})"


ModuleIdx = yardl.UInt32
"""This is the type for the index over "modules".
It is an unsigned integer that runs over all the "modules" starting from 0.

The correspondence between this integer and a module is not encoded in this model,
but only in the "helpers".
It corresponds to effectively incrementing the moduleIdx in nested loops:
1. ScannerGeometry.replicated_modules
2. replicated_module.transforms
(with the moduleIdx running faster over the 2nd loop)
"""


class Subject:
    name: typing.Optional[str]
    id: str

    def __init__(self, *,
        name: typing.Optional[str] = None,
        id: str = "",
    ):
        self.name = name
        self.id = id

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Subject)
            and self.name == other.name
            and self.id == other.id
        )

    def __str__(self) -> str:
        return f"Subject(name={self.name}, id={self.id})"

    def __repr__(self) -> str:
        return f"Subject(name={repr(self.name)}, id={repr(self.id)})"


class Institution:
    name: str
    address: str

    def __init__(self, *,
        name: str = "",
        address: str = "",
    ):
        self.name = name
        self.address = address

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Institution)
            and self.name == other.name
            and self.address == other.address
        )

    def __str__(self) -> str:
        return f"Institution(name={self.name}, address={self.address})"

    def __repr__(self) -> str:
        return f"Institution(name={repr(self.name)}, address={repr(self.address)})"


class ExternalSignalTypeEnum(yardl.OutOfRangeEnum):
    ECG_TRACE = 0
    ECG_TRIGGER = 1
    RESP_TRACE = 2
    RESP_TRIGGER = 3
    OTHER_MOTION_SIGNAL = 4
    OTHER_MOTION_TRIGGER = 5
    EXTERNAL_SYNC = 6
    MR_PULSE_START = 7
    OTHER = 8
    """other options, to be listed in the future"""


class ExternalSignal:
    type: ExternalSignalTypeEnum
    description: str
    id: yardl.UInt32

    def __init__(self, *,
        type: ExternalSignalTypeEnum = ExternalSignalTypeEnum.ECG_TRACE,
        description: str = "",
        id: yardl.UInt32 = 0,
    ):
        self.type = type
        self.description = description
        self.id = id

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ExternalSignal)
            and self.type == other.type
            and self.description == other.description
            and self.id == other.id
        )

    def __str__(self) -> str:
        return f"ExternalSignal(type={self.type}, description={self.description}, id={self.id})"

    def __repr__(self) -> str:
        return f"ExternalSignal(type={repr(self.type)}, description={repr(self.description)}, id={repr(self.id)})"


class ExamInformation:
    """Items describing the exam (incomplete)"""

    subject: Subject
    institution: Institution
    protocol: typing.Optional[str]
    start_of_acquisition: typing.Optional[yardl.DateTime]
    external_signals: list[ExternalSignal]
    """A list of all possible signals that are recorded in the stream.
    Actual values will be in recorded as ExternalSignalTimeBlock
    """


    def __init__(self, *,
        subject: typing.Optional[Subject] = None,
        institution: typing.Optional[Institution] = None,
        protocol: typing.Optional[str] = None,
        start_of_acquisition: typing.Optional[yardl.DateTime] = None,
        external_signals: typing.Optional[list[ExternalSignal]] = None,
    ):
        self.subject = subject if subject is not None else Subject()
        self.institution = institution if institution is not None else Institution()
        self.protocol = protocol
        self.start_of_acquisition = start_of_acquisition
        self.external_signals = external_signals if external_signals is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ExamInformation)
            and self.subject == other.subject
            and self.institution == other.institution
            and self.protocol == other.protocol
            and self.start_of_acquisition == other.start_of_acquisition
            and self.external_signals == other.external_signals
        )

    def __str__(self) -> str:
        return f"ExamInformation(subject={self.subject}, institution={self.institution}, protocol={self.protocol}, startOfAcquisition={self.start_of_acquisition}, externalSignals={self.external_signals})"

    def __repr__(self) -> str:
        return f"ExamInformation(subject={repr(self.subject)}, institution={repr(self.institution)}, protocol={repr(self.protocol)}, startOfAcquisition={repr(self.start_of_acquisition)}, externalSignals={repr(self.external_signals)})"


class Direction:
    """3D direction vector (normalized to 1)"""

    c: npt.NDArray[np.float32]

    def __init__(self, *,
        c: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.c = c if c is not None else np.zeros((3,), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Direction)
            and yardl.structural_equal(self.c, other.c)
        )

    def __str__(self) -> str:
        return f"Direction(c={self.c})"

    def __repr__(self) -> str:
        return f"Direction(c={repr(self.c)})"


class DirectionMatrix:
    """Orthonormal matrix
    direction_of_first_axis = matrix * [1, 0 ,0] (as a column vector)
    """

    matrix: npt.NDArray[np.float32]

    def __init__(self, *,
        matrix: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.matrix = matrix if matrix is not None else np.zeros((3, 3,), dtype=np.dtype(np.float32))

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, DirectionMatrix)
            and yardl.structural_equal(self.matrix, other.matrix)
        )

    def __str__(self) -> str:
        return f"DirectionMatrix(matrix={self.matrix})"

    def __repr__(self) -> str:
        return f"DirectionMatrix(matrix={repr(self.matrix)})"


class Atom:
    """Atom definition in terms of Z and A"""

    mass_number: yardl.UInt32
    """A"""

    atomic_number: yardl.UInt32
    """Z"""


    def __init__(self, *,
        mass_number: yardl.UInt32 = 0,
        atomic_number: yardl.UInt32 = 0,
    ):
        self.mass_number = mass_number
        self.atomic_number = atomic_number

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Atom)
            and self.mass_number == other.mass_number
            and self.atomic_number == other.atomic_number
        )

    def __str__(self) -> str:
        return f"Atom(massNumber={self.mass_number}, atomicNumber={self.atomic_number})"

    def __repr__(self) -> str:
        return f"Atom(massNumber={repr(self.mass_number)}, atomicNumber={repr(self.atomic_number)})"


class BulkMaterial:
    """Specification of materials used in the scanner.
    TODO agree with vendors if this information can be supplied and to what accuracy
    Ideally this list should be reasonably accurate to be useful for Monte Carlo simulations, but can be approximate.
    """

    id: yardl.UInt32
    """unique id that can be used to refer to the material in voxelised maps etc"""

    name: str
    """informative string, not standardised.
    Expected examples:
    detecting: BGO, LSO, LYSO, LaBr, GAGG, plastic
    non-detecting: tungsten, lead
    """

    density: yardl.Float32
    """density of the material
    Units: g/cc
    """

    atoms: list[Atom]
    """List of atoms"""

    mass_fractions: list[yardl.Float32]
    """List of massFractions for the atoms.
    constraint: sum of massFractions should be 1
    constraint:  size(atoms) == size(massFractions)
    """


    def __init__(self, *,
        id: yardl.UInt32 = 0,
        name: str = "",
        density: yardl.Float32 = 0.0,
        atoms: typing.Optional[list[Atom]] = None,
        mass_fractions: typing.Optional[list[yardl.Float32]] = None,
    ):
        self.id = id
        self.name = name
        self.density = density
        self.atoms = atoms if atoms is not None else []
        self.mass_fractions = mass_fractions if mass_fractions is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, BulkMaterial)
            and self.id == other.id
            and self.name == other.name
            and self.density == other.density
            and self.atoms == other.atoms
            and self.mass_fractions == other.mass_fractions
        )

    def __str__(self) -> str:
        return f"BulkMaterial(id={self.id}, name={self.name}, density={self.density}, atoms={self.atoms}, massFractions={self.mass_fractions})"

    def __repr__(self) -> str:
        return f"BulkMaterial(id={repr(self.id)}, name={repr(self.name)}, density={repr(self.density)}, atoms={repr(self.atoms)}, massFractions={repr(self.mass_fractions)})"


class SinglesHistogramLevelType(yardl.OutOfRangeEnum):
    """Type definition for how single histograms are stored.
    Many scanners are able to store singles accumulated in some time intervals, i.e.
    histogrammed (as opposed to a list of singles with their corresponding DetElIdx).
    However, some scanners do not store this information at the smallest detector resolution.
    Therefore, PETSIRD currently supports a total singles count for each module as well.

    Note that PETSIRD allows giving singles count summed over all energy windows. This is
    currently not encode in this enum, but is derived from the size of the histogram.
    See SinglesHistogramTimeBlock.
    """

    NONE = 0
    """singles histograms are not stored at all"""

    MODULE = 1
    """singles counts per module"""

    ALL = 2
    """singles counts for each DetElIdx"""


class CoincidencePolicy(yardl.OutOfRangeEnum):
    """Type definition for how to encode how the scanner handles multiple coincidences when recording the prompts.
    Due to various effects (such as high count rate, prompt gammas), it is possible that multiple single
    events are detected within the coincidence window. This type encodes some different ways
    that this multiple events are handled, and recorded in the coincidence stream.
    """

    REJECT_MULTIPLES = 0
    """multiples will be rejected"""

    MULTIPLES_AS_ALL_COINCIDENCES = 1
    """multiples will be stored as a sequence of all pairs, e.g. a triple leads to 3 pairs"""

    MULTIPLES_AS_SEQUENTIAL_COINCIDENCES = 2
    """multiples will be stored as a sequence pairs, e.g. a triple leads to 2 pairs
    (single1 and single2, single2 and single3)
    """

    OTHER = 3
    """other options, to be listed in the future"""


class ScannerInformation:
    model_name: str
    scanner_geometry: ScannerGeometry
    """Geometric information for all detecting elements
    All coordinates are in the PET gantry coordinate system.
    """

    bulk_materials: list[BulkMaterial]
    """List of materials present in the scanner geometry. The `material_id`s there will refer to the
    identifiers in this list below.
    """

    gantry_alignment: typing.Optional[RigidTransformation]
    """Fixed transformation to reference location for this scanner.
    This field can be used to encode alignment with the CT or MRI gantry for instance.
    The transformation should convert from the PET gantry coordinate system to the reference.
    An empty field implies the identity transformation.
    """

    tof_bin_edges: npt.NDArray[np.float32]
    """Edge information for TOF bins in mm (given as from first to last edge, so there is one more edge than the number of bins)
    0 corresponds to the same arrival time. Negative numbers indicate that the first detecting element detected first.
    For instance, a coincidence event is stored as 2 detectionBins, denoting the arrival time at the first
    detecting element t1 and the arrival time at the second detecting element t2, we store (t1-t2)*c/2.
    Note: for non-TOF scanners, this defines the coincidence window
    TODO: this currently assumes equal size for each TOF bin, but some scanners "stretch" TOF bins depending on length of LOR
    """

    tof_resolution: yardl.Float32
    """TOF resolution (as FWHM) in mm
    Scanner coincidence timing resolution (CTR) without tof-binning
    """

    event_energy_bin_edges: npt.NDArray[np.float32]
    """Edge information (in keV) for energy windows used for coincidences, triples etc
    (given as from first to last edge, so there is one more edge than the number of bins)
    """

    energy_resolution_at_511: yardl.Float32
    """FWHM of photopeak for incoming gamma of 511 keV, expressed as a ratio w.r.t. 511"""

    singles_histogram_level: SinglesHistogramLevelType
    """level at which the singles histograms are stored"""

    singles_histogram_energy_bin_edges: npt.NDArray[np.float32]
    """Edge information (in keV) for energy windows used for singles histograms
    (given as from first to last edge, so there is one more edge than the number of bins)
    In many cases, this could be the same as eventEnergyBinEdges, but is an independent field
    for flexibility.
    Constraint: (singlesHistogramLevel == SinglesHistogramLevelType.none && numberOfSinglesHistogramEnergyBins >= 1) ||
                (singlesHistogramLevel != SinglesHistogramLevelType.none && size(singlesHistogramEnergyBinEdges) == 0)
    """

    coincidence_policy: CoincidencePolicy
    """Encode how the scanner handles multiple coincidences"""

    delayed_coincidences_are_stored: bool
    """a flag to indicate of delayed coincidences are recorded in the stream"""

    triple_events_are_stored: bool
    """a flag to indicate of triple events are recorded in the stream"""

    detection_efficiencies: DetectionEfficiencies
    """coincidence detection efficiencies"""


    def __init__(self, *,
        model_name: str = "",
        scanner_geometry: typing.Optional[ScannerGeometry] = None,
        bulk_materials: typing.Optional[list[BulkMaterial]] = None,
        gantry_alignment: typing.Optional[RigidTransformation] = None,
        tof_bin_edges: typing.Optional[npt.NDArray[np.float32]] = None,
        tof_resolution: yardl.Float32 = 0.0,
        event_energy_bin_edges: typing.Optional[npt.NDArray[np.float32]] = None,
        energy_resolution_at_511: yardl.Float32 = 0.0,
        singles_histogram_level: SinglesHistogramLevelType = SinglesHistogramLevelType.NONE,
        singles_histogram_energy_bin_edges: typing.Optional[npt.NDArray[np.float32]] = None,
        coincidence_policy: CoincidencePolicy = CoincidencePolicy.REJECT_MULTIPLES,
        delayed_coincidences_are_stored: bool = False,
        triple_events_are_stored: bool = False,
        detection_efficiencies: typing.Optional[DetectionEfficiencies] = None,
    ):
        self.model_name = model_name
        self.scanner_geometry = scanner_geometry if scanner_geometry is not None else ScannerGeometry()
        self.bulk_materials = bulk_materials if bulk_materials is not None else []
        self.gantry_alignment = gantry_alignment
        self.tof_bin_edges = tof_bin_edges if tof_bin_edges is not None else np.zeros((0), dtype=np.dtype(np.float32))
        self.tof_resolution = tof_resolution
        self.event_energy_bin_edges = event_energy_bin_edges if event_energy_bin_edges is not None else np.zeros((0), dtype=np.dtype(np.float32))
        self.energy_resolution_at_511 = energy_resolution_at_511
        self.singles_histogram_level = singles_histogram_level
        self.singles_histogram_energy_bin_edges = singles_histogram_energy_bin_edges if singles_histogram_energy_bin_edges is not None else np.zeros((0), dtype=np.dtype(np.float32))
        self.coincidence_policy = coincidence_policy
        self.delayed_coincidences_are_stored = delayed_coincidences_are_stored
        self.triple_events_are_stored = triple_events_are_stored
        self.detection_efficiencies = detection_efficiencies if detection_efficiencies is not None else DetectionEfficiencies()

    def number_of_tof_bins(self) -> yardl.Size:
        return self.tof_bin_edges.size - 1

    def number_of_event_energy_bins(self) -> yardl.Size:
        return self.event_energy_bin_edges.size - 1

    def number_of_singles_histogram_energy_bins(self) -> yardl.Size:
        return self.singles_histogram_energy_bin_edges.size - 1

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ScannerInformation)
            and self.model_name == other.model_name
            and self.scanner_geometry == other.scanner_geometry
            and self.bulk_materials == other.bulk_materials
            and (other.gantry_alignment is None if self.gantry_alignment is None else (other.gantry_alignment is not None and self.gantry_alignment == other.gantry_alignment))
            and yardl.structural_equal(self.tof_bin_edges, other.tof_bin_edges)
            and self.tof_resolution == other.tof_resolution
            and yardl.structural_equal(self.event_energy_bin_edges, other.event_energy_bin_edges)
            and self.energy_resolution_at_511 == other.energy_resolution_at_511
            and self.singles_histogram_level == other.singles_histogram_level
            and yardl.structural_equal(self.singles_histogram_energy_bin_edges, other.singles_histogram_energy_bin_edges)
            and self.coincidence_policy == other.coincidence_policy
            and self.delayed_coincidences_are_stored == other.delayed_coincidences_are_stored
            and self.triple_events_are_stored == other.triple_events_are_stored
            and self.detection_efficiencies == other.detection_efficiencies
        )

    def __str__(self) -> str:
        return f"ScannerInformation(modelName={self.model_name}, scannerGeometry={self.scanner_geometry}, bulkMaterials={self.bulk_materials}, gantryAlignment={self.gantry_alignment}, tofBinEdges={self.tof_bin_edges}, tofResolution={self.tof_resolution}, eventEnergyBinEdges={self.event_energy_bin_edges}, energyResolutionAt511={self.energy_resolution_at_511}, singlesHistogramLevel={self.singles_histogram_level}, singlesHistogramEnergyBinEdges={self.singles_histogram_energy_bin_edges}, coincidencePolicy={self.coincidence_policy}, delayedCoincidencesAreStored={self.delayed_coincidences_are_stored}, tripleEventsAreStored={self.triple_events_are_stored}, detectionEfficiencies={self.detection_efficiencies})"

    def __repr__(self) -> str:
        return f"ScannerInformation(modelName={repr(self.model_name)}, scannerGeometry={repr(self.scanner_geometry)}, bulkMaterials={repr(self.bulk_materials)}, gantryAlignment={repr(self.gantry_alignment)}, tofBinEdges={repr(self.tof_bin_edges)}, tofResolution={repr(self.tof_resolution)}, eventEnergyBinEdges={repr(self.event_energy_bin_edges)}, energyResolutionAt511={repr(self.energy_resolution_at_511)}, singlesHistogramLevel={repr(self.singles_histogram_level)}, singlesHistogramEnergyBinEdges={repr(self.singles_histogram_energy_bin_edges)}, coincidencePolicy={repr(self.coincidence_policy)}, delayedCoincidencesAreStored={repr(self.delayed_coincidences_are_stored)}, tripleEventsAreStored={repr(self.triple_events_are_stored)}, detectionEfficiencies={repr(self.detection_efficiencies)})"


class Header:
    scanner: ScannerInformation
    exam: typing.Optional[ExamInformation]

    def __init__(self, *,
        scanner: typing.Optional[ScannerInformation] = None,
        exam: typing.Optional[ExamInformation] = None,
    ):
        self.scanner = scanner if scanner is not None else ScannerInformation()
        self.exam = exam

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, Header)
            and self.scanner == other.scanner
            and self.exam == other.exam
        )

    def __str__(self) -> str:
        return f"Header(scanner={self.scanner}, exam={self.exam})"

    def __repr__(self) -> str:
        return f"Header(scanner={repr(self.scanner)}, exam={repr(self.exam)})"


class TimeInterval:
    """Time interval in milliseconds since start of acquisition"""

    start: yardl.UInt32
    stop: yardl.UInt32

    def __init__(self, *,
        start: yardl.UInt32 = 0,
        stop: yardl.UInt32 = 0,
    ):
        self.start = start
        self.stop = stop

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TimeInterval)
            and self.start == other.start
            and self.stop == other.stop
        )

    def __str__(self) -> str:
        return f"TimeInterval(start={self.start}, stop={self.stop})"

    def __repr__(self) -> str:
        return f"TimeInterval(start={repr(self.start)}, stop={repr(self.stop)})"


class TripleEvent:
    """All information about a triple event specified as identifiers (i.e. discretized)."""

    detection_bins: list[DetectionBin]
    """identifiers of the two detecting elements (see doc for DetectionBin)
    Note that it is possible that 2 "elementary detecting elements" are equal (e.g. for
    inter-crystal Compton events)
    """

    tof_indices: list[yardl.UInt32]
    """timing differences (converted to mm) w.r.t. first event, stored as
    indices into the tofBinEdges field in the ScannerInformation
    Note: only 2, corresponding to the arrival time differences of the second and third detectionBins
    listed w.r.t. the first detectionBin
    """


    def __init__(self, *,
        detection_bins: typing.Optional[list[DetectionBin]] = None,
        tof_indices: typing.Optional[list[yardl.UInt32]] = None,
    ):
        self.detection_bins = detection_bins if detection_bins is not None else [DetectionBin() for _ in range(3)]
        self.tof_indices = tof_indices if tof_indices is not None else [0] * 2

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TripleEvent)
            and self.detection_bins == other.detection_bins
            and self.tof_indices == other.tof_indices
        )

    def __str__(self) -> str:
        return f"TripleEvent(detectionBins={self.detection_bins}, tofIndices={self.tof_indices})"

    def __repr__(self) -> str:
        return f"TripleEvent(detectionBins={repr(self.detection_bins)}, tofIndices={repr(self.tof_indices)})"


class EventTimeBlock:
    time_interval: TimeInterval
    """time interval for this time block
    We suggest that for each coincidence/multiple event, the earliest time of arrival
    of a photon is used for deciding which time block the event is entered in.
    However, the impact of this choice is negligible and therefore can be vendor dependent.
    """

    prompt_events: list[CoincidenceEvent]
    """list of prompts in this time block
    TODO might be better to use !array
    """

    delayed_events: typing.Optional[list[CoincidenceEvent]]
    """optional list of delayed coincidences in this time block"""

    triple_events: typing.Optional[list[TripleEvent]]
    """optional list of triple coincidences in this time block"""


    def __init__(self, *,
        time_interval: typing.Optional[TimeInterval] = None,
        prompt_events: typing.Optional[list[CoincidenceEvent]] = None,
        delayed_events: typing.Optional[list[CoincidenceEvent]] = None,
        triple_events: typing.Optional[list[TripleEvent]] = None,
    ):
        self.time_interval = time_interval if time_interval is not None else TimeInterval()
        self.prompt_events = prompt_events if prompt_events is not None else []
        self.delayed_events = delayed_events
        self.triple_events = triple_events

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, EventTimeBlock)
            and self.time_interval == other.time_interval
            and self.prompt_events == other.prompt_events
            and self.delayed_events == other.delayed_events
            and self.triple_events == other.triple_events
        )

    def __str__(self) -> str:
        return f"EventTimeBlock(timeInterval={self.time_interval}, promptEvents={self.prompt_events}, delayedEvents={self.delayed_events}, tripleEvents={self.triple_events})"

    def __repr__(self) -> str:
        return f"EventTimeBlock(timeInterval={repr(self.time_interval)}, promptEvents={repr(self.prompt_events)}, delayedEvents={repr(self.delayed_events)}, tripleEvents={repr(self.triple_events)})"


class ExternalSignalTimeBlock:
    """A time block containing the values for a particular external signal.
    See ExamInformation.externalSignals for the list of possible signals.
    """

    time_interval: TimeInterval
    """time interval for this time block
    Note: for triggers, the time interval should be very short (and can be zero).
    """

    signal_id: yardl.UInt32
    """refer to ExternalSignal.id
    Constraint: value has to be listed in ExamInformation.externalSignals.
    """

    signal_values: list[yardl.Float32]
    """Note for triggers, this field is to be ignored"""


    def __init__(self, *,
        time_interval: typing.Optional[TimeInterval] = None,
        signal_id: yardl.UInt32 = 0,
        signal_values: typing.Optional[list[yardl.Float32]] = None,
    ):
        self.time_interval = time_interval if time_interval is not None else TimeInterval()
        self.signal_id = signal_id
        self.signal_values = signal_values if signal_values is not None else []

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, ExternalSignalTimeBlock)
            and self.time_interval == other.time_interval
            and self.signal_id == other.signal_id
            and self.signal_values == other.signal_values
        )

    def __str__(self) -> str:
        return f"ExternalSignalTimeBlock(timeInterval={self.time_interval}, signalID={self.signal_id}, signalValues={self.signal_values})"

    def __repr__(self) -> str:
        return f"ExternalSignalTimeBlock(timeInterval={repr(self.time_interval)}, signalID={repr(self.signal_id)}, signalValues={repr(self.signal_values)})"


class BedMovementTimeBlock:
    time_interval: TimeInterval
    """time interval for this time block"""

    transform: RigidTransformation

    def __init__(self, *,
        time_interval: typing.Optional[TimeInterval] = None,
        transform: typing.Optional[RigidTransformation] = None,
    ):
        self.time_interval = time_interval if time_interval is not None else TimeInterval()
        self.transform = transform if transform is not None else RigidTransformation()

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, BedMovementTimeBlock)
            and self.time_interval == other.time_interval
            and self.transform == other.transform
        )

    def __str__(self) -> str:
        return f"BedMovementTimeBlock(timeInterval={self.time_interval}, transform={self.transform})"

    def __repr__(self) -> str:
        return f"BedMovementTimeBlock(timeInterval={repr(self.time_interval)}, transform={repr(self.transform)})"


class GantryMovementTimeBlock:
    time_interval: TimeInterval
    """time interval for this time block"""

    transform: RigidTransformation

    def __init__(self, *,
        time_interval: typing.Optional[TimeInterval] = None,
        transform: typing.Optional[RigidTransformation] = None,
    ):
        self.time_interval = time_interval if time_interval is not None else TimeInterval()
        self.transform = transform if transform is not None else RigidTransformation()

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, GantryMovementTimeBlock)
            and self.time_interval == other.time_interval
            and self.transform == other.transform
        )

    def __str__(self) -> str:
        return f"GantryMovementTimeBlock(timeInterval={self.time_interval}, transform={self.transform})"

    def __repr__(self) -> str:
        return f"GantryMovementTimeBlock(timeInterval={repr(self.time_interval)}, transform={repr(self.transform)})"


class DeadTimeTimeBlock:
    """A time block that stores the dead-time information for the given interval
    Dead-time is encoded as "alive_time_fraction", i.e. 1 - dead_time_fraction
    A component-based model is used, where the total alive-time for a pair of DetectionBins
    is computed as the product of the (singles) alive-time of each detector times the
    coincidence-alive-time of the corresponding module-pair, i.e. conceptually
    aliveTimeFraction(detectionBin0, detectionBin1) =
      singlesAliveTimeFraction(detectionBin0) *
      singlesAliveTimeFraction(detectionBin1) *
      moduleCoincidenceAliveTimeFraction[module(detectionBin0), module(detectionBin1)]
    Constraint: the time covered by all event time blocks has to be covered by dead-time time blocks
    """

    time_interval: TimeInterval
    """time interval for this time block"""

    singles_alive_time_fraction: npt.NDArray[np.float32]
    """Singles dead-time array for the time interval, stored as fractions of "alive time"
    (1 means no dead-time, 0 means no detected counts)
    If sizeOfEnergyIdxDimension == 1, the fraction is assumed to be the same
    for all energy windows.
    Constraint: sizeOfDetElIdxDimension == number of all possible unique DetElIdxs
    Constraint: (sizeOfEnergyIdxDimension == 1) or (sizeOfEnergyIdxDimension == ScannerInformation.numberOfEventEnergyBins)
    """

    module_coincidence_alive_time_fraction: npt.NDArray[np.float32]
    """coincidence dead-time array for 2 modules in coincidence, stored as fractions of "alive time"
    (1 means no dead-time, 0 means no detected coincidences)
    If the size of this 2D array is (1,1), it is assumed that the corresponding alive-fraction is the same for all modules.
    Constraint: size(moduleCoincidenceAliveTimeFraction, 0) == 1 or total number of modules of all types
    Constraint: size(moduleCoincidenceAliveTimeFraction, 1) == 1 or total number of modules of all types
    Constraint: this matrix has to be symmetric
    """


    def __init__(self, *,
        time_interval: typing.Optional[TimeInterval] = None,
        singles_alive_time_fraction: typing.Optional[npt.NDArray[np.float32]] = None,
        module_coincidence_alive_time_fraction: typing.Optional[npt.NDArray[np.float32]] = None,
    ):
        self.time_interval = time_interval if time_interval is not None else TimeInterval()
        self.singles_alive_time_fraction = singles_alive_time_fraction if singles_alive_time_fraction is not None else np.zeros((0, 0), dtype=np.dtype(np.float32))
        self.module_coincidence_alive_time_fraction = module_coincidence_alive_time_fraction if module_coincidence_alive_time_fraction is not None else np.zeros((0, 0), dtype=np.dtype(np.float32))

    def size_of_det_el_idx_dimension(self) -> yardl.Size:
        return self.singles_alive_time_fraction.shape[0]

    def size_of_energy_idx_dimension(self) -> yardl.Size:
        return self.singles_alive_time_fraction.shape[1]

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, DeadTimeTimeBlock)
            and self.time_interval == other.time_interval
            and yardl.structural_equal(self.singles_alive_time_fraction, other.singles_alive_time_fraction)
            and yardl.structural_equal(self.module_coincidence_alive_time_fraction, other.module_coincidence_alive_time_fraction)
        )

    def __str__(self) -> str:
        return f"DeadTimeTimeBlock(timeInterval={self.time_interval}, singlesAliveTimeFraction={self.singles_alive_time_fraction}, moduleCoincidenceAliveTimeFraction={self.module_coincidence_alive_time_fraction})"

    def __repr__(self) -> str:
        return f"DeadTimeTimeBlock(timeInterval={repr(self.time_interval)}, singlesAliveTimeFraction={repr(self.singles_alive_time_fraction)}, moduleCoincidenceAliveTimeFraction={repr(self.module_coincidence_alive_time_fraction)})"


class SinglesHistogramTimeBlock:
    """A time block that stores a singles histogram.
    See SinglesHistogramLevelType for information.
    Constraint: if ScannerInformation.singlesHistogramLevel == SinglesHistogramLevelType.none, there should
        be no time blocks of this type in the stream.
        Otherwise, the union of SinglesHistogramTimeBlock.timeInterval should be at least as large as the union of all EventTimeBlocks.timeInterval
    Constraint: if singles histograms are recorded, the time covered by all event time blocks
    has to be covered by singles histogram time blocks.
    """

    time_interval: TimeInterval
    singles_histogram: npt.NDArray[np.uint64]
    """A 2D histogram of all singles (after energy discrimination) occuring in the timeInterval.
    The dimensions correspond to positional information (i.e. moduleIdx or detElIdx, see below)
    and energy index. The latter index refers to ScannerInformation.singlesHistogramEnergyBinEdges.
    Note that in future, we might consider also storing singles before energy discremination,
    but this is currently not supported.

    If ScannerInformation.singlesHistogramLevel == SinglesHistogramLevelType.module, the
    positionalIdx runs over all modules.
    If ScannerInformation.singlesHistogramLevel == SinglesHistogramLevelType.all, the
    positionalIdx runs over all DetElIdxs.
    Constraint: (singlesHistogramLevel == module && sizeOfPositionalIdxDimension == total number of modules of all types) ||
                (singlesHistogramLevel == all && sizeOfPositionalIdxDimension == total number of detecting elements in all modules)
    Constraint:  sizeOfEnergyIdxDimension == ScannerInformation.numberOfSinglesHistogramEnergyBins
    """


    def __init__(self, *,
        time_interval: typing.Optional[TimeInterval] = None,
        singles_histogram: typing.Optional[npt.NDArray[np.uint64]] = None,
    ):
        self.time_interval = time_interval if time_interval is not None else TimeInterval()
        self.singles_histogram = singles_histogram if singles_histogram is not None else np.zeros((0, 0), dtype=np.dtype(np.uint64))

    def size_of_positional_idx_dimension(self) -> yardl.Size:
        return self.singles_histogram.shape[0]

    def size_of_energy_idx_dimension(self) -> yardl.Size:
        return self.singles_histogram.shape[1]

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, SinglesHistogramTimeBlock)
            and self.time_interval == other.time_interval
            and yardl.structural_equal(self.singles_histogram, other.singles_histogram)
        )

    def __str__(self) -> str:
        return f"SinglesHistogramTimeBlock(timeInterval={self.time_interval}, singlesHistogram={self.singles_histogram})"

    def __repr__(self) -> str:
        return f"SinglesHistogramTimeBlock(timeInterval={repr(self.time_interval)}, singlesHistogram={repr(self.singles_histogram)})"


class TimeBlock:
    EventTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[EventTimeBlock]"]]
    ExternalSignalTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[ExternalSignalTimeBlock]"]]
    BedMovementTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[BedMovementTimeBlock]"]]
    GantryMovementTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[GantryMovementTimeBlock]"]]
    DeadTimeTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[DeadTimeTimeBlock]"]]
    SinglesHistogramTimeBlock: typing.ClassVar[type["TimeBlockUnionCase[SinglesHistogramTimeBlock]"]]

class TimeBlockUnionCase(TimeBlock, yardl.UnionCase[_T]):
    pass

TimeBlock.EventTimeBlock = type("TimeBlock.EventTimeBlock", (TimeBlockUnionCase,), {"index": 0, "tag": "EventTimeBlock"})
TimeBlock.ExternalSignalTimeBlock = type("TimeBlock.ExternalSignalTimeBlock", (TimeBlockUnionCase,), {"index": 1, "tag": "ExternalSignalTimeBlock"})
TimeBlock.BedMovementTimeBlock = type("TimeBlock.BedMovementTimeBlock", (TimeBlockUnionCase,), {"index": 2, "tag": "BedMovementTimeBlock"})
TimeBlock.GantryMovementTimeBlock = type("TimeBlock.GantryMovementTimeBlock", (TimeBlockUnionCase,), {"index": 3, "tag": "GantryMovementTimeBlock"})
TimeBlock.DeadTimeTimeBlock = type("TimeBlock.DeadTimeTimeBlock", (TimeBlockUnionCase,), {"index": 4, "tag": "DeadTimeTimeBlock"})
TimeBlock.SinglesHistogramTimeBlock = type("TimeBlock.SinglesHistogramTimeBlock", (TimeBlockUnionCase,), {"index": 5, "tag": "SinglesHistogramTimeBlock"})
del TimeBlockUnionCase

class TimeFrameInformation:
    """A sequence of time intervals (could be consecutive)"""

    time_frames: list[TimeInterval]

    def __init__(self, *,
        time_frames: typing.Optional[list[TimeInterval]] = None,
    ):
        self.time_frames = time_frames if time_frames is not None else []

    def number_of_time_frames(self) -> yardl.Size:
        return len(self.time_frames)

    def __eq__(self, other: object) -> bool:
        return (
            isinstance(other, TimeFrameInformation)
            and self.time_frames == other.time_frames
        )

    def __str__(self) -> str:
        return f"TimeFrameInformation(timeFrames={self.time_frames})"

    def __repr__(self) -> str:
        return f"TimeFrameInformation(timeFrames={repr(self.time_frames)})"


def _mk_get_dtype():
    dtype_map: dict[typing.Union[type, types.GenericAlias], typing.Union[np.dtype[typing.Any], typing.Callable[[tuple[type, ...]], np.dtype[typing.Any]]]] = {}
    get_dtype = _dtypes.make_get_dtype_func(dtype_map)

    dtype_map.setdefault(DetElIdx, np.dtype(np.uint32))
    dtype_map.setdefault(DetectionBin, np.dtype([('det_el_idx', np.dtype(np.uint32)), ('energy_idx', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(CoincidenceEvent, np.dtype([('detection_bins', get_dtype(DetectionBin), (2,)), ('tof_idx', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(SGID, np.dtype(np.uint32))
    dtype_map.setdefault(ModulePairEfficiencies, np.dtype([('values', np.dtype(np.object_)), ('sgid', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(DetectionEfficiencies, np.dtype([('detection_bin_efficiencies', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('module_pair_sgidlut', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('module_pair_efficiencies_vector', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True))
    dtype_map.setdefault(SolidVolume, lambda type_args: np.dtype([('shape', get_dtype(type_args[0])), ('material_id', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(Coordinate, np.dtype([('c', np.dtype(np.float32), (3,))], align=True))
    dtype_map.setdefault(BoxShape, np.dtype([('corners', get_dtype(Coordinate), (8,))], align=True))
    dtype_map.setdefault(BoxSolidVolume, get_dtype(types.GenericAlias(SolidVolume, (BoxShape,))))
    dtype_map.setdefault(AnnulusShape, np.dtype([('inner_radius', np.dtype(np.float32)), ('outer_radius', np.dtype(np.float32)), ('thickness', np.dtype(np.float32)), ('angular_range', np.dtype(np.float32), (2,))], align=True))
    dtype_map.setdefault(GeometricShape, np.dtype(np.object_))
    dtype_map.setdefault(GenericSolidVolume, get_dtype(types.GenericAlias(SolidVolume, (GeometricShape,))))
    dtype_map.setdefault(RigidTransformation, np.dtype([('matrix', np.dtype(np.float32), (3, 4,))], align=True))
    dtype_map.setdefault(ReplicatedObject, lambda type_args: np.dtype([('object', get_dtype(type_args[0])), ('transforms', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(ReplicatedBoxSolidVolume, get_dtype(types.GenericAlias(ReplicatedObject, (BoxSolidVolume,))))
    dtype_map.setdefault(ReplicatedGenericSolidVolume, get_dtype(types.GenericAlias(ReplicatedObject, (GenericSolidVolume,))))
    dtype_map.setdefault(DetectorModule, np.dtype([('detecting_elements', np.dtype(np.object_)), ('non_detecting_elements', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(ReplicatedDetectorModule, get_dtype(types.GenericAlias(ReplicatedObject, (DetectorModule,))))
    dtype_map.setdefault(ScannerGeometry, np.dtype([('replicated_modules', np.dtype(np.object_)), ('non_detecting_volumes', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True))
    dtype_map.setdefault(ModuleIdx, np.dtype(np.uint32))
    dtype_map.setdefault(Subject, np.dtype([('name', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('id', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(Institution, np.dtype([('name', np.dtype(np.object_)), ('address', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(ExternalSignalTypeEnum, np.dtype(np.int32))
    dtype_map.setdefault(ExternalSignal, np.dtype([('type', get_dtype(ExternalSignalTypeEnum)), ('description', np.dtype(np.object_)), ('id', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(ExamInformation, np.dtype([('subject', get_dtype(Subject)), ('institution', get_dtype(Institution)), ('protocol', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('start_of_acquisition', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.datetime64))], align=True)), ('external_signals', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(Direction, np.dtype([('c', np.dtype(np.float32), (3,))], align=True))
    dtype_map.setdefault(DirectionMatrix, np.dtype([('matrix', np.dtype(np.float32), (3, 3,))], align=True))
    dtype_map.setdefault(Atom, np.dtype([('mass_number', np.dtype(np.uint32)), ('atomic_number', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(BulkMaterial, np.dtype([('id', np.dtype(np.uint32)), ('name', np.dtype(np.object_)), ('density', np.dtype(np.float32)), ('atoms', np.dtype(np.object_)), ('mass_fractions', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(SinglesHistogramLevelType, np.dtype(np.int32))
    dtype_map.setdefault(CoincidencePolicy, np.dtype(np.int32))
    dtype_map.setdefault(ScannerInformation, np.dtype([('model_name', np.dtype(np.object_)), ('scanner_geometry', get_dtype(ScannerGeometry)), ('bulk_materials', np.dtype(np.object_)), ('gantry_alignment', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(RigidTransformation))], align=True)), ('tof_bin_edges', np.dtype(np.object_)), ('tof_resolution', np.dtype(np.float32)), ('event_energy_bin_edges', np.dtype(np.object_)), ('energy_resolution_at_511', np.dtype(np.float32)), ('singles_histogram_level', get_dtype(SinglesHistogramLevelType)), ('singles_histogram_energy_bin_edges', np.dtype(np.object_)), ('coincidence_policy', get_dtype(CoincidencePolicy)), ('delayed_coincidences_are_stored', np.dtype(np.bool_)), ('triple_events_are_stored', np.dtype(np.bool_)), ('detection_efficiencies', get_dtype(DetectionEfficiencies))], align=True))
    dtype_map.setdefault(Header, np.dtype([('scanner', get_dtype(ScannerInformation)), ('exam', np.dtype([('has_value', np.dtype(np.bool_)), ('value', get_dtype(ExamInformation))], align=True))], align=True))
    dtype_map.setdefault(TimeInterval, np.dtype([('start', np.dtype(np.uint32)), ('stop', np.dtype(np.uint32))], align=True))
    dtype_map.setdefault(TripleEvent, np.dtype([('detection_bins', get_dtype(DetectionBin), (3,)), ('tof_indices', np.dtype(np.uint32), (2,))], align=True))
    dtype_map.setdefault(EventTimeBlock, np.dtype([('time_interval', get_dtype(TimeInterval)), ('prompt_events', np.dtype(np.object_)), ('delayed_events', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True)), ('triple_events', np.dtype([('has_value', np.dtype(np.bool_)), ('value', np.dtype(np.object_))], align=True))], align=True))
    dtype_map.setdefault(ExternalSignalTimeBlock, np.dtype([('time_interval', get_dtype(TimeInterval)), ('signal_id', np.dtype(np.uint32)), ('signal_values', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(BedMovementTimeBlock, np.dtype([('time_interval', get_dtype(TimeInterval)), ('transform', get_dtype(RigidTransformation))], align=True))
    dtype_map.setdefault(GantryMovementTimeBlock, np.dtype([('time_interval', get_dtype(TimeInterval)), ('transform', get_dtype(RigidTransformation))], align=True))
    dtype_map.setdefault(DeadTimeTimeBlock, np.dtype([('time_interval', get_dtype(TimeInterval)), ('singles_alive_time_fraction', np.dtype(np.object_)), ('module_coincidence_alive_time_fraction', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(SinglesHistogramTimeBlock, np.dtype([('time_interval', get_dtype(TimeInterval)), ('singles_histogram', np.dtype(np.object_))], align=True))
    dtype_map.setdefault(TimeBlock, np.dtype(np.object_))
    dtype_map.setdefault(TimeFrameInformation, np.dtype([('time_frames', np.dtype(np.object_))], align=True))

    return get_dtype

get_dtype = _mk_get_dtype()

